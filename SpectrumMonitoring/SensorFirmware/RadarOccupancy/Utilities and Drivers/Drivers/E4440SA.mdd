<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>1.0</FileVersion>
   <DriverName>C:\Program Files\MATLAB\R2006b\work\IQ_Analyzer_v3.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Vector Analyzer</InstrumentType>
   <InstrumentManufacturer>Agilent Technologies Inc.</InstrumentManufacturer>
   <InstrumentModel>E4440A</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify>*IDN?</Identify>
   <Reset>*RST</Reset>
   <Selftest>*TST?</Selftest>
   <Error>System:Error?</Error>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
interface=get(obj,'interface');
set(interface,'InputBufferSize',1e6);
set(interface,'Timeout',10);
set(interface,'ByteOrder','bigEndian');
fclose(interface);</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>InstrumentCommand</Type>
   </ConnectInitCode>
   <CleanupCode>
      <Type>InstrumentCommand</Type>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>ADCRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ADC:RANG</ConfigureCommand>
                     <QueryCommand>ADC:RANG?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="AutoRange" Value="AUTO"/>
                     <Enum Name="Bypass" Value="NONE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>AUTO</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>ApplyAmpCorr</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CORR:CSET:ALL</ConfigureCommand>
                     <QueryCommand>CORR:CSET:ALL?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>AvgMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>AVER:TCON</ConfigureCommand>
                     <QueryCommand>AVER:TCON?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Exponential" Value="EXP"/>
                     <Enum Name="Repeat" Value="REP"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>EXP</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>AVGTYPE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>AVER:TYPE</ConfigureCommand>
                     <QueryCommand>AVER:TYPE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Log-Pwr" Value="LOG"/>
                     <Enum Name="RMS" Value="RMS"/>
                     <Enum Name="Volts" Value="SCAL"/>
                     <Enum Name="Max" Value="MAX"/>
                     <Enum Name="Min" Value="MIN"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Log-Pwr</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>BaseACQtime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:WAV:SWE:TIME</ConfigureCommand>
                     <QueryCommand>:WAV:SWE:TIME?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="100.0" Min="1.0E-7"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0E-7</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Set the measurement acquisition time. It is used to specify the length of
the time capture record.

Factory Preset: 2.0 ms
100.0 ms, for Basic Mode (PSA)
10.0 ms, for NADC, PDC

Range: 100 ns to 100 s

Default Unit: seconds

Remarks: To use this command for E4406A, the appropriate mode
should be selected with INSTrument:SELect.
For PSA you must be in the Basic, Analog Modulation,
cdmaOne, cdma2000, 1xEV-DO, W-CDMA, GSM,
EDGE, NADC, or PDC mode to use this command. Use
INSTrument:SELect to set the mode.</Description>
            </Property>
            <Property>
               <Name>BaseAutoPwrRng</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>POW:RANG:AUTO</ConfigureCommand>
                     <QueryCommand>POW:RANG:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="On" Value="ON"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the RF port auto ranging. Only usable in Basic Mode</Description>
            </Property>
            <Property>
               <Name>BaseCFREQ</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FREQ:CENT</ConfigureCommand>
                     <QueryCommand>FREQ:CENT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the center frequency when analyzer is in Base Mode</Description>
            </Property>
            <Property>
               <Name>BaseSPAN</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SPEC:FREQ:SPAN</ConfigureCommand>
                     <QueryCommand>SPEC:FREQ:SPAN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets the analyzer Span while in Base Mode.</Description>
            </Property>
            <Property>
               <Name>BaseWNDW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SPEC:FFT:WIND</ConfigureCommand>
                     <QueryCommand>SPEC:FFT:WIND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Flat" Value="FLAT"/>
                     <Enum Name="Blackman-Haris" Value="BH4T"/>
                     <Enum Name="Blackman" Value="BLAC"/>
                     <Enum Name="Gaussian" Value="GAUS"/>
                     <Enum Name="Hamming" Value="HAMM"/>
                     <Enum Name="Hanning" Value="HANN"/>
                     <Enum Name="Kaiser-Bessel70" Value="KB70"/>
                     <Enum Name="Kaiser-Bessel90" Value="KB90"/>
                     <Enum Name="KAiser-Bessel110" Value="KB110"/>
                     <Enum Name="Uniform" Value="UNIF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Flat</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the window type when the analyzer is Base Mode</Description>
            </Property>
            <Property>
               <Name>CarrierTrackState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>DANLMethod</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>FFTWindow</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>FilterType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>FREF</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ROSC:EXT:FREQ</ConfigureCommand>
                     <QueryCommand>ROSC:EXT:FREQ?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="3.0E7" Min="1000000.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000000.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets the external reference frequency input argument is in hertz</Description>
            </Property>
            <Property>
               <Name>FREFMODE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ROSC:SOUR</ConfigureCommand>
                     <QueryCommand>ROSC:SOUR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Internal" Value="INT"/>
                     <Enum Name="External" Value="EXT"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Internal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the frequency reference to either internal or external</Description>
            </Property>
            <Property>
               <Name>IFPATH</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>iGenAnnotation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>DISP:ENAB</ConfigureCommand>
                     <QueryCommand>DISP:ENAB?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>On</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Turns the scrren annotation on or off</Description>
            </Property>
            <Property>
               <Name>iGenAtten</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:POW:ATT</ConfigureCommand>
                     <QueryCommand>:POW:ATT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="70.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the input attenuation in dB.</Description>
            </Property>
            <Property>
               <Name>iGenAttenChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
propertyValue = str2double(query(iFace, ':POW:ATT?'));</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':POW:ATT ',num2str(propertyValue)]);

SetAtten = get(obj, 'iGenAtten');
if SetAtten ~= propertyValue;
  error('SA:Property:Atten:SettingIncorrect', 'The attenuation has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="70.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the input attenuation in dB.
The set portion of this property checks the attenuation value after it is set to ensure that it was set properly. If it was not then an error is raised. </Description>
            </Property>
            <Property>
               <Name>iGenAutoCal</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
temp = deblank(query(IFace, 'CAL:AUTO?'));
if strncmpi(temp,'ALERT',4)
    propertyValue = 'Alert';
elseif strncmpi(temp, 'ON', 2)
    propertyValue = 'On';
else
  propertyValue = 'Off';
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, ['CAL:AUTO ',propertyValue]);</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="Alert" Value="ALERT"/>
                     <Enum Name="Partial" Value="ALERT"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>On</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the auto cal feature on the E4440.
'Off' and 'Alert' amount to the same thing on the E4440. In either of these states
there are still some quick calibrations that take place. It is not possible to turn these off.

Allowed inputs:
Auto = auto calibration is on, E4440 will run alignments whenever necessary.
Off = E4440 will not automatically run alignments but quick cals will still ocurr. A message will
	be displayed on the screen when an alignment is necessary.
Alert = same as Off
Partial = this is only available on the PXA for the E4440 this sets the auto cal to alert.</Description>
            </Property>
            <Property>
               <Name>iGenAutoCalChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenAutoCal');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, ['CAL:AUTO ',propertyValue]);

% check to make sure the property is set as requested.
SetAutoCal = get(obj, 'iGenAutoCal');
if strncmpi(propertyValue, 'PART', 4);
  propertyValue = 'Alert';
end
if ~strncmpi(SetAutoCal,propertyValue,2);
  error('SA:Property:AutoCal:SettingIncorrect', 'The auto calibration feature has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="ON"/>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="Alert" Value="ALERT"/>
                     <Enum Name="Partial" Value="ALERT"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>On</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the auto cal feature on the E4440.
'Off' and 'Alert' amount to the same thing on the E4440. In either of these states
there are still some quick calibrations that take place. It is not possible to turn these off.
The set portion of this property checks the auto cal setting after it is set to ensure that it was set properly. If it was not then an error is raised. 

Allowed inputs:
Auto = auto calibration is on, E4440 will run alignments whenever necessary.
Off = E4440 will not automatically run alignments but quick cals will still ocurr. A message will
	be displayed on the screen when an alignment is necessary.
Alert = same as Off
Partial = this is only available on the PXA for the E4440 this sets the auto cal to alert.</Description>
            </Property>
            <Property>
               <Name>iGenByteOrder</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FORM:BORD</ConfigureCommand>
                     <QueryCommand>FORM:BORD?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Normal" Value="NORM"/>
                     <Enum Name="Swapped" Value="SWAP"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Normal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets the byte order of the analyzer.
Use Normal for Motorola processors
Use Swapped for PCs</Description>
            </Property>
            <Property>
               <Name>iGenCenterFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:CENT</ConfigureCommand>
                     <QueryCommand>:FREQ:CENT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.699999E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>13.26e9</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the center frequency.</Description>
            </Property>
            <Property>
               <Name>iGenCenterFreqChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenCenterFreq');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':FREQ:CENT ',num2str(propertyValue)]);

SetCF = get(obj, 'iGenCenterFreq');
% Check to make sure set CF is within +/- .1% of the desired value
if ~WithinTol(SetCF, propertyValue, 0.001)
  error('SA:Property:CenterFreq:SettingIncorrect', 'The center frequency has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.699999E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>13.26e9</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the center frequency.

if setting this property it is checked to make sure it has been set properly.
If the setting is not set as requested an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenCFStepSize</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FREQ:CENT:STEP</ConfigureCommand>
                     <QueryCommand>FREQ:CENT:STEP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the center frequency step size</Description>
            </Property>
            <Property>
               <Name>iGenCFStepSizeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
propertyValue = str2double(query(IFace, 'FREQ:CENT:STEP?'));</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, ['FREQ:CENT:STEP ',num2str(propertyValue)]);

% have to round propertyValue because E4440 does not allow fraction of Hz in step size.
% WithinTol is not enough when using 1 Hz step size.
SetCFStepSize = get(obj, 'iGenCFStepSize');
if ~WithinTol(SetCFStepSize,round(propertyValue),.001);
  error('SA:Property:CFStepSize:SettingIncorrect',...
      'The center frequency step size has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the center frequency step size
The set portion of this property checks the centre frequency step size value after it is set
to ensure that it was set properly. If it was not then an error is raised. </Description>
            </Property>
            <Property>
               <Name>iGenDataFormat</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FORM</ConfigureCommand>
                     <QueryCommand>FORM?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ASCII" Value="ASC,+8"/>
                     <Enum Name="INT 32" Value="INT,+32"/>
                     <Enum Name="REAL 32" Value="REAL,+32"/>
                     <Enum Name="REAL 64" Value="REAL,+64"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ASCII</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the data format.

Allowed inputs are:
ASCII
INT 32
REAL 32
REAL 64</Description>
            </Property>
            <Property>
               <Name>iGenDataFormatChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenDataFormat');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, ['FORM ',propertyValue]);

SetFormat = query(iFace, 'FORM?');
if strcmpi(propertyValue(1:4),'REAL')
  N = 8;
else
  N = 3;
end
if ~strncmpi(SetFormat,propertyValue,N);
  error('SA:Property:DataFormat:SettingIncorrect', 'The data format has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ASCII" Value="ASC,+8"/>
                     <Enum Name="INT 32" Value="INT,+32"/>
                     <Enum Name="REAL 32" Value="REAL,+32"/>
                     <Enum Name="REAL 64" Value="REAL,+64"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ASC</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the data format.
The set portion of this property checks the attenuation value after it is set to ensure that it was set properly. If it was not then an error is raised.

Allowed inputs are:
ASCII
INT 32
REAL 32
REAL 64</Description>
            </Property>
            <Property>
               <Name>iGenDetector</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
temp = query(iFace, 'DET?')
SetDet = temp(1:3)
switch SetDet
  case 'AVE'
    AverType = query(iFace, 'AVER:TYPE?')
    if strncmpi(AverType, 'RMS', 3)
      propertyValue = 'RMS';
    elseif strncmpi(AverType, 'LOG', 3)
      propertyValue = 'Log Average';
    elseif strncmpi(AverType, 'SCAL', 3)
      propertyValue = 'Volt Average';
    else
      propertyValue = {};
    end
  case 'NOR'
    propertyValue = 'Normal';
  case 'POS'
    propertyValue = 'Positive';
  case 'NEG'
    propertyValue = 'Negative';
  case 'SAM'
    propertyValue = 'Sample';
  case 'QPE'
    propertyValue = 'Quasi-Peak';
  case 'EAV'
    propertyValue = 'EMI Average';
  case 'EPO'
    propertyValue = 'EMI Peak';
  case 'MPO'
    propertyValue = 'MIL Peak';
  otherwise
    propertyValue = {};
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object
iFace = get(obj, 'interface');

if strncmpi(propertyValue, 'AVE', 3)
  fprintf(iFace, ['DET ',propertyValue(1:5)]);
  fprintf(iFace, propertyValue(7:end));
else
  fprintf(iFace, ['DET ',propertyValue]);
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Log Average" Value="AVER; AVER:TYPE LOG"/>
                     <Enum Name="Negative" Value="NEG"/>
                     <Enum Name="Positive" Value="POS"/>
                     <Enum Name="Normal" Value="NORM"/>
                     <Enum Name="Sample" Value="SAMP"/>
                     <Enum Name="RMS" Value="AVER; AVER:TYPE RMS"/>
                     <Enum Name="Quasi-Peak" Value="QPE"/>
                     <Enum Name="Volt Average" Value="AVER; AVER:TYPE SCAL"/>
                     <Enum Name="EMI Average" Value="EAV"/>
                     <Enum Name="EMI Peak" Value="EPOS"/>
                     <Enum Name="MIL Peak" Value="MPOS"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Normal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the detector type

Acceptable inputs are:
Average = video averaging
Negative = negative peak
Positive = positive peak
Normal
Sample
RMS = RMS averaging
QuasiPeak = Quasi-Peak</Description>
            </Property>
            <Property>
               <Name>iGenDetectorChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenDetector');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');

if strncmpi(propertyValue, 'AVE', 3)
  fprintf(iFace, ['DET ',propertyValue(1:5)]);
  fprintf(iFace, propertyValue(7:end));
else
  fprintf(iFace, ['DET ',propertyValue]);
end

% check it
SetDet = query(iFace, 'DET?')
% if an averaging detector find out what kind
if strncmpi(SetDet, 'AVE', 3)
  AverType = query(iFace, 'AVER:TYPE?');
end
% check to make sure desired detector matches actual setting.
if strncmpi(propertyValue(1:3),'AVER',3)
  if ~strncmpi(AverType(end-3:end-1), propertyValue(end-2:end),3)
    error('SA:Property:Detector:SettingIncorrect', 'The detector has not been set as requested ');
  end
else
  if ~strncmpi(propertyValue, SetDet, 3)
    error('SA:Property:Detector:SettingIncorrect', 'The detector has not been set as requested ');
  end
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Log Average" Value="AVER; AVER:TYPE LOG"/>
                     <Enum Name="Negative" Value="NEG"/>
                     <Enum Name="Positive" Value="POS"/>
                     <Enum Name="Normal" Value="NORM"/>
                     <Enum Name="Sample" Value="SAMP"/>
                     <Enum Name="RMS" Value="AVER; AVER:TYPE RMS"/>
                     <Enum Name="Quasi-Peak" Value="QPE"/>
                     <Enum Name="Volt Average" Value="AVER; AVER:TYPE SCAL"/>
                     <Enum Name="EMI Average" Value="EAV"/>
                     <Enum Name="EMI Peak" Value="EPOS"/>
                     <Enum Name="MIL Peak" Value="MPOS"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Normal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the detector type
The set portion of this property checks the detector type after it is set to ensure that it was set properly. If it was not then an error is raised. 

Acceptable inputs are:
Average = video averaging
Negative = negative peak
Positive = positive peak
Normal
Sample
RMS = RMS averaging
QuasiPeak = Quasi-Peak</Description>
            </Property>
            <Property>
               <Name>iGenHasGPS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 0;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>indicates whether or not SA is GPS capable.</Description>
            </Property>
            <Property>
               <Name>iGenHostID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:HID?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>iGenInstDescID</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
out = get(IFace, 'RemoteHost');
idx = findstr(out, '.');
propertyValue = ['Agilent E4440 IP',out(idx(end):end)];</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>iGenIntPreamp</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:POW:GAIN</ConfigureCommand>
                     <QueryCommand>:POW:GAIN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="1"/>
                     <Enum Name="Off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the status of the internal pre-amp.

</Description>
            </Property>
            <Property>
               <Name>iGenIntPreampChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
out = str2double(query(IFace, ':POW:GAIN?'));
if out == 1
  propertyValue = 'On';
else
  propertyValue = 'Off';
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':POW:GAIN ',num2str(propertyValue)]);

SetPreamp = str2double(query(iFace, ':POW:GAIN?'));
if SetPreamp ~= str2double(propertyValue);
  error('SA:Property:IntPreamp:SettingIncorrect', 'The preamp state has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="1"/>
                     <Enum Name="Off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the status of the internal pre-amp.
If setting the state of the preamp the setting is checked and if it is not set as desired
an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenMeasMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:INST:SEL</ConfigureCommand>
                     <QueryCommand>:INST:SEL?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Spectrum Analyzer" Value="SA"/>
                     <Enum Name="CDMA One" Value="CDMA"/>
                     <Enum Name="NADC" Value="NADC"/>
                     <Enum Name="PDC" Value="PDC"/>
                     <Enum Name="Basic" Value="BASIC"/>
                     <Enum Name="W-CDMA" Value="WCDMA"/>
                     <Enum Name="CDMA 2000" Value="CDMA2K"/>
                     <Enum Name="GSM Edge" Value="EDGEGSM"/>
                     <Enum Name="Phase Noise" Value="PNOISE"/>
                     <Enum Name="CDMA 1xEVDO" Value="CDMA1XEV"/>
                     <Enum Name="WLAN" Value="WLAN"/>
                     <Enum Name="Noise Figure" Value="NFIGURE"/>
                     <Enum Name="VSA Link" Value="LINK"/>
                     <Enum Name="Measuring Reciever" Value="MRECEIVE"/>
                     <Enum Name="Digital Demod" Value="DMODULATION"/>
                     <Enum Name="TDS CDMA" Value="TDSCDMA"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Spectrum Analyzer</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the E4440 Measurement mode. Not all modes are available on all E4440s.
Use iGenMeasModesInstalled to determine what modes are available for the E4440 that
is currently connected. 

Allowed inputs are:
Spectrum Analyzer
CDMA One
NADC
PDC
Basic
W-CDMA
CDMA 2000
GSM Edge
Phase Noise
CDMA 1xEVDO
WLAN
Noise Figure
VSA Link
Measuring Reciever
Digital Demod</Description>
            </Property>
            <Property>
               <Name>iGenMeasModeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenMeasMode');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface')
fprintf(iFace, [':INST:SEL ',propertyValue]);

% read mode and make sure it was set correctly
SetMode = deblank(query(iFace, ':INST:SEL?'));
if ~strcmpi(SetMode, propertyValue)
  error('SA:Property:MeasMode:SettingIncorrect', 'The measurement mode has not been set as requested ');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Spectrum Analyzer" Value="SA"/>
                     <Enum Name="CDMA One" Value="CDMA"/>
                     <Enum Name="NADC" Value="NADC"/>
                     <Enum Name="PDC" Value="PDC"/>
                     <Enum Name="Basic" Value="BASIC"/>
                     <Enum Name="W-CDMA" Value="WCDMA"/>
                     <Enum Name="CDMA 2000" Value="CDMA2K"/>
                     <Enum Name="GSM Edge" Value="EDGEGSM"/>
                     <Enum Name="Phase Noise" Value="PNOISE"/>
                     <Enum Name="CDMA 1xEVDO" Value="CDMA1XEV"/>
                     <Enum Name="WLAN" Value="WLAN"/>
                     <Enum Name="Noise Figure" Value="NFIGURE"/>
                     <Enum Name="VSA Link" Value="LINK"/>
                     <Enum Name="Measuring Receiver" Value="MRECEIVE"/>
                     <Enum Name="Digital Demod" Value="DMODULATION"/>
                     <Enum Name="TDS CDMA" Value="TDSCDMA"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Spectrum Analyzer</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the E4440 Measurement mode. Not all modes are available on all E4440s.
Use iGenMeasModesInstalled to determine what modes are available for the E4440 that
is currently connected. 
The set portion of this property will check to make sure the mode has been set as desired.
If it has not been an error will be raised.

Allowed inputs are:
Spectrum Analyzer
CDMA One
NADC
PDC
Basic
W-CDMA
CDMA 2000
GSM Edge
Phase Noise
CDMA 1xEVDO
WLAN
Noise Figure
VSA Link
Measuring Reciever
Digital Demod</Description>
            </Property>
            <Property>
               <Name>iGenOneDBcompPt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
CF = str2double(query(interface, ':FREQ:CENT?'));
if CF &gt; 2e7 &amp;&amp; CF &lt;= 2e8
  propertyValue = 3;
elseif CF &gt; 2e8 &amp;&amp; CF &lt;= 3e9
  propertyValue = 7;
elseif CF &gt; 3e9 &amp;&amp; CF &lt;= 6.6e9
  propertyValue = 4;
elseif CF &gt; 6.6e9 &amp;&amp; CF &lt;= 26.5e9
  propertyValue = 0;
else
  propertyValue = [];
end
 </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>iGenOperationComplete</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>*OPC?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Operation Complete
*OPC
*OPC?
The *OPC command sets bit 0 in the standard event status register to
1 when pending operations have finished. It does not hold off
subsequent operations.
The *OPC? query stops new commands from being processed until the
current processing is complete. Then it returns a 1, and the program
continues. This query can be used to synchronize events of other
instruments on the external bus.
The instrument does not wait for completion of all processes for these
commands. The processes that are monitored are identified in the
STATus:OPERation resgister. These include:
For example, if you want to verify the completion of both calibration
and waiting for trigger set :STAT:OPER:ENAB 33 and monitor any
changes.
Key Type: There is no equivalent front-panel key.

PSA Process    STATus:OPER     Byte Value
               Register Bit

Calibrating          0                1
Sweeping             3                8
MEASuring            4                16
(not in all modes)
Waiting for trigger  5                32</Description>
            </Property>
            <Property>
               <Name>iGenPreampMax</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
SAOptions = query(interface, 'SYST:OPT?');
if ~isempty(findstr(SAOptions, '110'))
  propertyValue = 50e9; % 50 GHz
elseif ~isempty(findstr(SAOptions, '1DS'))
  propertyValue = 3e9; % 3 GHz
else
  propertyValue = 0; % no Preamp
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="5.0E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>This property is read only and can be used to query the maximum
freqeuncy the preamp will work up to. If no preamp is present this
property will return 0.</Description>
            </Property>
            <Property>
               <Name>iGenRBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND</ConfigureCommand>
                     <QueryCommand>:BAND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8000000.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>3e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth.</Description>
            </Property>
            <Property>
               <Name>iGenRBWChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenRBW');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':BAND ',num2str(propertyValue)]);

SetRBW = get(obj, 'iGenRBW');
if ~WithinTol(SetRBW, propertyValue, .1)
  error('SA:Property:RBW:SettingIncorrect', 'The RBW has not been set as requested ');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8000000.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>3e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth.

This should not be used unless setting the RBW to known available values. 1 3 10 30 100 300 ... up to 1000000 then in 1 MHz steps to 8 MHz 
except for 7 MHz.

If Setting the property the setting is checked to make sure the instrument has been set properly.
If it is not set properly an error is raised. Not all RBW are available so if a strange value is desired this will return an error. 
Use iGenRBW instead.</Description>
            </Property>
            <Property>
               <Name>iGenRefLevel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:WIND:TRAC:Y:RLEV</ConfigureCommand>
                     <QueryCommand>:DISP:WIND:TRAC:Y:RLEV?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="30.0" Min="-170.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the reference level.
Possible reference levels are dependent on the attenuation setting.</Description>
            </Property>
            <Property>
               <Name>iGenRefLevelChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenRefLevel');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':DISP:WIND:TRAC:Y:RLEV ',num2str(propertyValue)]);

SetRefLevel = get(obj, 'iGenRefLevel');
if ~WithinTol(SetRefLevel, propertyValue, .01)
  error('SA:Property:RefLevel:SettingIncorrect','The reference level has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="30.0" Min="-170.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the reference level.
Possible reference levels are dependent on the attenuation setting.

The set command will check the reference level to make sure it has been set as requested.
If it has not been then an error will be raised.</Description>
            </Property>
            <Property>
               <Name>iGenScalePerDiv</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:WIND:TRAC:Y:PDIV</ConfigureCommand>
                     <QueryCommand>:DISP:WIND:TRAC:Y:PDIV?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="20.0" Min="0.1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the logarithmic units per vertical graticule division on the display.

</Description>
            </Property>
            <Property>
               <Name>iGenScalePerDivChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenScalePerDiv');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':DISP:WIND:TRAC:Y:PDIV ',num2str(propertyValue)]);

SetScale = get(obj, 'iGenScalePerDiv');
if ~WithinTol(SetScale, propertyValue, .1)
  error('SA:Property:ScalePerDiv:SettingIncorrect','The Y scale per division has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="20.0" Min="0.1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the logarithmic units per vertical graticule division on the display.

When setting the y scale units the setting is checked to make sure it was set properly.
If it has not been then an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenScaleType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:WIND:TRAC:Y:SPAC</ConfigureCommand>
                     <QueryCommand>:DISP:WIND:TRAC:Y:SPAC?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Linear" Value="LIN"/>
                     <Enum Name="Log" Value="LOG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Log</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the vertical scale type for the display.

Allowed inputs are:
Linear
Log</Description>
            </Property>
            <Property>
               <Name>iGenScaleTypeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenScaleType');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, [':DISP:WIND:TRAC:Y:SPAC ',propertyValue]);

SetScaleType = query(IFace, ':DISP:WIND:TRAC:Y:SPAC?');
if ~strncmpi(SetScaleType, propertyValue, 3)
  error('SA:Property:ScaleType:SettingIncorrect','The Y scale type has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Linear" Value="LIN"/>
                     <Enum Name="Log" Value="LOG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Log</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the vertical scale type for the display.

Allowed inputs are:
Linear
Log

When setting the scale type the setting is checked to make sure it has been set properly.
If this is not the case an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenSpan</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:SPAN</ConfigureCommand>
                     <QueryCommand>:FREQ:SPAN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.649E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the frequency span.</Description>
            </Property>
            <Property>
               <Name>iGenSpanChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj,'iGenSpan');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':FREQ:SPAN ',num2str(propertyValue)]);

SetSpan = get(obj, 'iGenSpan');
% Check to make sure set CF is within +/- .1% of the desired value
if ~WithinTol(SetSpan, propertyValue, 0.001)
  error('SA:Property:Span:SettingIncorrect', 'The span frequency has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.649E10" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the frequency span.

The set command checks the setting to make sure it was set as desired.
If it has not been then an error is raised.

An incorrect error may be raised if the span is set to a fractional hertz value.
This is because the E4440 does not set the span to fractions of a hertz.</Description>
            </Property>
            <Property>
               <Name>iGenStartFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:STAR</ConfigureCommand>
                     <QueryCommand>:FREQ:STAR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>-1.0E8</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the start frequency</Description>
            </Property>
            <Property>
               <Name>iGenStartFreqChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenStartFreq');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':FREQ:STAR ',num2str(propertyValue)]);

SetStartFreq = get(obj, 'iGenStartFreq');
% Check to make sure set CF is within +/- .1% of the desired value
if ~WithinTol(SetStartFreq, propertyValue, 0.001)
  error('SA:Property:StartFreq:SettingIncorrect', 'The start frequency has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>This property sets or queries the start frequency.

When setting this property an error will be raised if the start freqeuncy is not set a s requested.</Description>
            </Property>
            <Property>
               <Name>iGenStopFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FREQ:STOP</ConfigureCommand>
                     <QueryCommand>:FREQ:STOP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the stop frequency

</Description>
            </Property>
            <Property>
               <Name>iGenStopFreqChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenStopFreq');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':FREQ:STOP ',num2str(propertyValue)]);

SetStopFreq = get(obj, 'iGenStopFreq');
% Check to make sure set stop freq is within +/- .1% of the desired value
if ~WithinTol(SetStopFreq, propertyValue, 0.001)
  error('SA:Property:StopFreq:SettingIncorrect', 'The stop frequency has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.7E10" Min="-1.0E8"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the stop frequency.

When setting the stop freqeuncy it is checked to make sure it was set as requested.
If this is not the case then an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenSweepMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:INIT:CONT</ConfigureCommand>
                     <QueryCommand>:INIT:CONT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Continuous" Value="1"/>
                     <Enum Name="Single" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Continuous</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the sweep mode.

acceptable inputs are:
Continuous
Single</Description>
            </Property>
            <Property>
               <Name>iGenSweepModeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenSweepMode');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, [':INIT:CONT ',propertyValue]);

SetSweepMode = str2double(query(IFace, ':INIT:CONT?'));
if SetSweepMode ~= str2double(propertyValue)
  error('SA:Property:SweepMode:SettingIncorrect','The sweep mode has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Continuous" Value="1"/>
                     <Enum Name="Single" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Continuous</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the sweep mode.

acceptable inputs are:
Continuous
Single

When setting this property the setting is checked to make sure it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenSweepPoints</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SWE:POIN</ConfigureCommand>
                     <QueryCommand>:SWE:POIN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8192.0" Min="2.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>601</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the number of number of trace points.

Minimum number of points = 178 in non-zero span mode.
Minimum number of points = 2 in zero span mode.

</Description>
            </Property>
            <Property>
               <Name>iGenSweepPointsChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenSweepPoints');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':SWE:POIN ',num2str(propertyValue)]);

SetSweepPoints = get(obj, 'iGenSweepPoints');

if SetSweepPoints ~= propertyValue
  error('SA:Property:SweepPoints:SettingIncorrect', 'The number of sweep points has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8192.0" Min="2.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>601</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the number of number of trace points.

Minimum number of points = 178 in non-zero span mode.
Minimum number of points = 2 in zero span mode.

When setting this property the setting is checked to make sure it was set properly.
If it is not set properly an error is raised.

An error will be raised if the analyzer is not in zero span mode and the number of points is set
to less than 178. This is the minimum number of points when not in zero span mode.</Description>
            </Property>
            <Property>
               <Name>iGenSweepsToAvg</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:AVER:COUN</ConfigureCommand>
                     <QueryCommand>:AVER:COUN?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8192.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the number of sweeps over which to video average.
</Description>
            </Property>
            <Property>
               <Name>iGenSweepsToAvgChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenSweepsToAvg');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':AVER:COUN ',num2str(propertyValue)]);

SetSweepsToAvg = get(obj, 'iGenSweepsToAvg');

if SetSweepsToAvg ~= propertyValue
  error('SA:Property:SweepsToAvg:SettingIncorrect', 'The number of sweeps to average has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8192.0" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the number of sweeps over which to video average.

When setting this property the setting is checked to make sure it was set properly.
If it is not set properly an error is raised.
</Description>
            </Property>
            <Property>
               <Name>iGenSweepTime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SWE:TIME</ConfigureCommand>
                     <QueryCommand>:SWE:TIME?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="6000.0" Min="1.0E-6"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>.01</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trace sweep time.

When setting the sweep time it is checked to make sure that it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenSweepTimeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenSweepTime');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':SWE:TIME ',num2str(propertyValue)]);

SetST = get(obj, 'iGenSweepTime');
% Check to make sure set CF is within +/- .1% of the desired value
if ~WithinTol(SetST, propertyValue, 0.01)
  error('SA:Property:SweepTime:SettingIncorrect', 'The sweep time has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="6000.0" Min="1.0E-6"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>.01</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trace sweep time.

When setting the sweep time it is checked to make sure that it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenSystemTime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
propertyValue = str2double(query(IFace, ':SYST:TIME?'));</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>This property reads the time as reported by the spectrum analyzer.</Description>
            </Property>
            <Property>
               <Name>iGenTrigDelay</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:TRIG:DEL</ConfigureCommand>
                     <QueryCommand>:TRIG:DEL?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="0.5" Min="-0.15"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger delay.</Description>
            </Property>
            <Property>
               <Name>iGenTrigDelayChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenTrigDelay');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':TRIG:DEL ',num2str(propertyValue)]);

SetTrigDelay = get(obj, 'iGenTrigDelay');

if ~WithinTol(SetTrigDelay, propertyValue, 0.0001)
  error('SA:Property:TrigDelay:SettingIncorrect', 'The trigger delay has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="0.5" Min="-0.15"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger delay.

When setting the sweep time it is checked to make sure that it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenTrigDelayState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>TRIG:DEL:STAT</ConfigureCommand>
                     <QueryCommand>TRIG:DEL:STAT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the trigger delay state</Description>
            </Property>
            <Property>
               <Name>iGenTrigLevel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:TRIG:VID:LEV</ConfigureCommand>
                     <QueryCommand>:TRIG:VID:LEV?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="0.0" Min="-100.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>-10</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger level for video trigger.</Description>
            </Property>
            <Property>
               <Name>iGenTrigLevelChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenTrigLevel');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':TRIG:VID:LEV ',num2str(propertyValue)]);

SetTrigLevel = get(obj, 'iGenTrigLevel');

if ~WithinTol(SetTrigLevel, propertyValue, 0.1)
  error('SA:Property:TrigLevel:SettingIncorrect', 'The video trigger level has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="0.0" Min="-100.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>-10</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the video trigger level.

When setting the sweep time it is checked to make sure that it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenTrigSlope</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:TRIG:SLOP</ConfigureCommand>
                     <QueryCommand>:TRIG:SLOP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Positive" Value="POS"/>
                     <Enum Name="Negative" Value="NEG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Positive</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger slope.</Description>
            </Property>
            <Property>
               <Name>iGenTrigSlopeChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenTrigSlope');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, [':TRIG:SLOP ',propertyValue]);

SetTrigSlope = deblank(query(IFace, ':TRIG:SLOP?'));
if ~strcmpi(SetTrigSlope, propertyValue)
  error('SA:Property:TrigSlope:SettingIncorrect','The trigger slope has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Positive" Value="POS"/>
                     <Enum Name="Negative" Value="NEG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Positive</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger slope.

When setting this property the setting is checked to make sure it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenTrigSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:TRIG:SOUR</ConfigureCommand>
                     <QueryCommand>:TRIG:SOUR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Free Run" Value="IMM"/>
                     <Enum Name="Video" Value="VID"/>
                     <Enum Name="Line" Value="LINE"/>
                     <Enum Name="External 1" Value="EXT"/>
                     <Enum Name="External 2" Value="EXT2"/>
                     <Enum Name="RF Burst" Value="RFB"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Free Run</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger source
</Description>
            </Property>
            <Property>
               <Name>iGenTrigSourceChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenTrigSource');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, [':TRIG:SOUR ',propertyValue]);

SetTrigSource = deblank(query(IFace, ':TRIG:SOUR?'));
if ~strcmpi(SetTrigSource, propertyValue)
  error('SA:Property:TrigSource:SettingIncorrect','The trigger source has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Free Run" Value="IMM"/>
                     <Enum Name="Video" Value="VID"/>
                     <Enum Name="Line" Value="LINE"/>
                     <Enum Name="External 1" Value="EXT"/>
                     <Enum Name="External 2" Value="EXT2"/>
                     <Enum Name="RF Burst" Value="RFB"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Free Run</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trigger source.

When setting this property the setting is checked to make sure it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenVBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND:VID</ConfigureCommand>
                     <QueryCommand>:BAND:VID?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="5.0E7" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>3e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the video bandwidth.</Description>
            </Property>
            <Property>
               <Name>iGenVBWChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenVBW');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':BAND:VID ',num2str(propertyValue)]);

SetVBW = get(obj, 'iGenVBW');

if ~WithinTol(SetVBW, propertyValue, 0.1)
  error('SA:Property:VBW:SettingIncorrect', 'The video bandwidth has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="5.0E7" Min="1.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>3e6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the video bandwidth.

When setting the sweep time it is checked to make sure that it was set properly.
If it is not set properly an error is raised.

This should be used cautiously when setting VBW to non standard values. While
the min and max values are set, not all values in between are available.</Description>
            </Property>
            <Property>
               <Name>iGenVideoAvg</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:AVER</ConfigureCommand>
                     <QueryCommand>:AVER?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="1"/>
                     <Enum Name="Off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trace averaging mode.
This command should be used with iGenSweepsToAvg to set the number of sweeps
to average when turning on video averaging.</Description>
            </Property>
            <Property>
               <Name>iGenVideoAvgChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenVideoAvg');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
IFace = get(obj, 'interface');
fprintf(IFace, [':AVER ',propertyValue]);

SetVidAvg = str2double(query(IFace, ':AVER?'));
if SetVidAvg ~= str2double(propertyValue)
  error('SA:Property:VideoAvg:SettingIncorrect','Video averaging has not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="On" Value="1"/>
                     <Enum Name="Off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the trace averaging mode.
This command should be used with iGenSweepsToAvg to set the number of sweeps
to average when turning on video averaging.

When setting this property the setting is checked to make sure it was set properly.
If it is not set properly an error is raised.</Description>
            </Property>
            <Property>
               <Name>iGenYUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:UNIT:POW</ConfigureCommand>
                     <QueryCommand>:UNIT:POW?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="dBm" Value="DBM"/>
                     <Enum Name="dBmV" Value="DBMV"/>
                     <Enum Name="dBuV" Value="DBUV"/>
                     <Enum Name="V" Value="V"/>
                     <Enum Name="W" Value="W"/>
                     <Enum Name="dBmA" Value="DBMA"/>
                     <Enum Name="dBuA" Value="DBUA"/>
                     <Enum Name="dBuVm" Value="DBUVM"/>
                     <Enum Name="dBuAm" Value="DBUAM"/>
                     <Enum Name="dBpt" Value="DBPT"/>
                     <Enum Name="dBg" Value="DBG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>dbm</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the Y axis units.
Allowed inputs are:
dbm
dbmv
dbuv
V
W
dbma
dbua
dbuvm
dbuam
dbpt
dbg</Description>
            </Property>
            <Property>
               <Name>iGenYUnitsChkResult</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = get(obj, 'iGenYUnits');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
iFace = get(obj, 'interface');
fprintf(iFace, [':UNIT:POW ',propertyValue]);

SetUnits = get(obj, 'iGenYUnits');
if ~strcmpi(SetUnits,propertyValue);
  error('SA:Property:YUnits:SettingIncorrect', 'The Y axis units have not been set as requested');
end</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="dBm" Value="DBM"/>
                     <Enum Name="dBmV" Value="DBMV"/>
                     <Enum Name="dBuV" Value="DBUV"/>
                     <Enum Name="V" Value="V"/>
                     <Enum Name="W" Value="W"/>
                     <Enum Name="dBmA" Value="DBMA"/>
                     <Enum Name="dBuA" Value="DBUA"/>
                     <Enum Name="dBuVm" Value="DBUVM"/>
                     <Enum Name="dBuAm" Value="DBUAM"/>
                     <Enum Name="dBpt" Value="DBPT"/>
                     <Enum Name="dBg" Value="DBG"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>dbm</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the Y axis units.
The set portion of this property checks the attenuation value after it is set to ensure that it was set properly. If it was not then an error is raised.
Allowed inputs are:
dbm
dbmv
dbuv
V
W
dbma
dbua
dbuvm
dbuam
dbpt
dbg</Description>
            </Property>
            <Property>
               <Name>IPandHostName</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SYST:COMM:LAN:IP</ConfigureCommand>
                     <QueryCommand>SYST:COMM:LAN:IP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>used to query or set the IP and Host names of the analyzer</Description>
            </Property>
            <Property>
               <Name>LLO</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SYST:KLOCK</ConfigureCommand>
                     <QueryCommand>SYST:KLOCK?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="On" Value="ON"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>used to query or set the local lockout of the analyzer</Description>
            </Property>
            <Property>
               <Name>LOPhNoiseOpt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>LOPhNoiseOptAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>MeasMethod</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>MeasType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CONF</ConfigureCommand>
                     <QueryCommand>CONF?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Spectrum" Value="SPEC"/>
                     <Enum Name="Waveform" Value="WAV"/>
                     <Enum Name="Monitor Spectrum" Value="MON"/>
                     <Enum Name="Spot Freq Meas" Value="SPF"/>
                     <Enum Name="Log Plot Meas" Value="LPL"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Spectrum</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>queries or sets the measuremnt type must be in either basic or phase noise modes.</Description>
            </Property>
            <Property>
               <Name>MeasView</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>NumOptions</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
propertyValue = 22;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>PreADCBPF</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qBaseBYTEORD</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qBaseCONFIG</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qBaseFFTLen</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qBaseNumType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qCALSTATUS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>STAT:QUES:CAL:COND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>queries the state of the cal align status to see if one is needed.</Description>
            </Property>
            <Property>
               <Name>qMeasScalars</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qMODECAT</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
PossibleModes = {'SA', 'BASIC', 'CDMA', 'CDMA1XEV', 'CDMA2K', 'EDGEGSM', 'LINK',...
  'NADC', 'NFIGURE', 'PDC', 'PNOISE', 'TDSCDMA', 'WCDMA'};
AvailableModes = query(interface, 'INST:CAT?');
propertyValue = [];
for ii = 1:length(PossibleModes)
  if ~isempty(findstr(AvailableModes, PossibleModes{ii}))
    propertyValue = [propertyValue ii];
  end
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>returns an integer array indicating what modes are available on the SA in use.
1 = Spectrum Analysis
2 = Basic
3 = CDMAOne
4 = CDMA1xEV-DO
5 = CDMA2000
6 = EDGE with GSM 
7 = 89600 VSA Link software
8 = NADC
9 = Noise Figure
10 = PDC
11 = Phase Noise
12 = TD-SCDMA
13 = W-CDMA for 3GPP
</Description>
            </Property>
            <Property>
               <Name>qONTIME</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:PON:ETIM?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>queries how long the analyzer has been on.</Description>
            </Property>
            <Property>
               <Name>qPOWERONTYPE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:PON:TYPE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qPRESETTYPE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
temp = query(interface, 'SYST:PRES:TYPE?');
if strncmpi(temp, 'MODE', 3)
  propertyValue = 'Mode';
elseif strncmpi(temp, 'FACT', 3)
  propertyValue = 'Factory';
elseif strncmpi(temp, 'USER', 3)
  propertyValue = 'User';
else
  % Some sort of Visa Error
  propertyValue = [];
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qSCPIVERSION</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>SYST:VERS?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qSTATOPERREG</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>STAT:OPER:COND?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>qUNCAL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
interface = get(obj, 'interface');
temp = str2double(query(interface, 'STAT:QUES:INT:UNC:COND?'));
if temp &gt; 0
  propertyValue = 1;
else
  propertyValue = 0;
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>RFCPL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:INP:COUP</ConfigureCommand>
                     <QueryCommand>:INP:COUP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ac" Value="AC"/>
                     <Enum Name="dc" Value="DC"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ac</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or gets the RF input coupling.


2.8.2 RF Coupling
Specifies alternating current (AC) or direct current (DC) coupling at the analyzer RF input
port. Selecting AC coupling switches in a blocking capacitor that blocks any DC voltage
present at the analyzer input. This decreases the input frequency range of the analyzer,
but prevents damage to the input circuitry of the analyzer if there is a DC voltage present
at the RF input.
In AC coupling mode, signals less than 20 MHz are not calibrated. You must switch to DC
coupling to see calibrated frequencies of less than 20 MHz. Note that the message
DC Coupled will be displayed on the analyzer when DC is selected.
Some amplitude specifications apply only when coupling is set to DC. Refer to the
appropriate amplitude specifications and characteristics for your analyzer.
CAUTION When operating in DC coupled mode, ensure protection of the input mixer by
limiting the input level to within 200 mV of 0 Vdc. In AC or DC coupling, limit
the input RF power to +30 dBm..
Key Path: Input/Output
Dependencies/
Couplings: In external mixing mode, input port and RF coupling selection are not
available. Not available on 40 GHz or 50 GHz analyzers.
State Saved: Saved in Instrument State
Factory Preset: AC
Remote Command:
:INPut:COUPling AC|DC
:INPut:COUPling?
Example: INP:COUP DC</Description>
            </Property>
            <Property>
               <Name>SAAttnAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:POW:ATT:AUTO</ConfigureCommand>
                     <QueryCommand>:POW:ATT:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the attenuation auto mode
This will not work in all modes

[:SENSe]:POWer[:RF]:ATTenuation:AUTO OFF|ON|0|1
[:SENSe]:POWer[:RF]:ATTenuation:AUTO?
Remote Command Notes: . The Reference Level setting may be affected when the
Attenuation is changed. See Ref Level.
Example:. POW:ATT 30
POW:ATT?
POW:ATT:AUTO ON
POW:ATT:AUTO?</Description>
            </Property>
            <Property>
               <Name>SABlank</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:ENAB</ConfigureCommand>
                     <QueryCommand>:DISP:ENAB?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="Off" Value="OFF"/>
                     <Enum Name="On" Value="ON"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Turns the display on/off. If enable is set to off, the display will appear to blank. This can
make the measurement run faster since the instrument does not have to update the
display after every data acquisition. There is often no need to update the display
information when using remote operation.
 Sending SYSTem:PRESet or *TST commands will turn it on. *RST will not.
Key Path: None, no front-panel control.
State Saved: Not saved in instrument state.</Description>
            </Property>
            <Property>
               <Name>SADate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

interface = get(obj, 'Interface');

date = query(interface, ':SYST:DATE?');

month_tab = {'Jan','Feb','Mar','Apr','May','Jun',...
             'Jul','Aug','Sep','Oct','Nov','Dec'}
             
coma_idx = find(date == ',');

year = date(coma_idx(1)-4:coma_idx(1)-1);
month = date(coma_idx(1)+1:coma_idx(2)-1);
month = month_tab{str2double(month)}
day = date(coma_idx(2)+1:end-1);
propertyValue = [month ' ' day ', ' year];</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description>THIS COMMAND HAS NOT BEEN TESTED!

Gets the instrument date

4.9.3.5 Set Date
Allows you to set the date of the real-time clock. Enter the date in the YYYYMMDD format.
Key Path: System, Time/Date
State Saved: Survives Preset and power cycle, but not saved in Instrument State nor
restored by System, Restore Sys Defaults.
SCPI Status Bits/
OPC Dependencies: None
Factory
Default: Not affected by Restore Sys Defaults.
Terminators: Unitless
Range: Year (YYYY): 1970 to 2029
Month (MM):01 to 12
Day: 01 to 30 or 31 (depending on the month)
Remote Command:
:SYSTem:DATE &lt;year&gt;,&lt;month&gt;,&lt;day&gt;
:SYSTem:DATE?
Example: SYST:DATE 2000,12,24 Sets the date to December 24, 2000</Description>
            </Property>
            <Property>
               <Name>SADetAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DET:AUTO</ConfigureCommand>
                     <QueryCommand>:DET:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the detector type auto mode.

See the SpecDet property for more info.</Description>
            </Property>
            <Property>
               <Name>SAInput</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:FEED</ConfigureCommand>
                     <QueryCommand>:FEED?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="AmpRef" Value="AREF"/>
                     <Enum Name="RFport" Value="RF"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>AmpRef</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the input signal path

2.8.1 Input Port
Brings up a menu of input signal sources, the most common one being the front panel RF
Input port.
Key Path: Input/Output
State Saved: Saved in Instrument State
Factory Preset: RF
Remote Command:
[:SENSe]:FEED RF|AREFerence|EMIXer
[:SENSe]:FEED?
Example: FEED AREF selects the 50 MHz amplitude reference as the signal input.
2.8.1.1 RF
Selects the front panel RF Input port to be the analyzer signal input.
Key Path: Input/Output, Input Port
Remote Command:
See Input Port on page 157
Example: FEED AREF selects the 50 MHz amplitude reference as the signal input.
2.8.1.2 Amptd Ref
Selects the 50 MHz, 25 dBm internal amplitude reference as the input signal.
Key Path: Input/Output, Input Port
Remote Command:
See Input Port on page 157
Example: FEED AREF selects the 50 MHz amplitude reference as the signal input.</Description>
            </Property>
            <Property>
               <Name>SAPeakExc</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:CALC:MARK:PEAK:EXC</ConfigureCommand>
                     <QueryCommand>:CALC:MARK:PEAK:EXC?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the peak excursion value

4.1.8.1 Peak Excursn
Sets the minimum amplitude variation of signals that the marker can identify as a
separate peak. For example, if a peak excursion value of 10 dB is selected, the marker Next
Peak function moves only to peaks that rise more than 10 dB above the Peak Threshold and
then fall back down by at least the Peak Excursn. This criteria applies to all traces. This
function applies to Next Peak, Next Peak Left, and Next Peak Right. If Peak Search is set to
Param, it also applies to Peak Search.
Key Path: Peak Search, Search Param
Dependencies/
Couplings: This function is not available when Y-Axis is set to Frequency instead of
Amplitude.
State Saved: Saved in instrument state.
Factory Preset: 6.0 dB
Factory
Default: 6.0 dB
Terminators: dB
Default Terminator: dB
Resolution/
Rounding/
Truncation: 0.01 dB
Knob Increment: 1 dB
Step Key
Increment: 1 dB
Range: 0.0 dB to 100 dB
Remote Command:
:CALCulate:MARKer[1]|2|3|4:PEAK:EXCursion &lt;rel_amplitude&gt;
:CALCulate:MARKer[1]|2|3|4:PEAK:EXCursion?
Remote Command Notes: CALC:MARK:PEAK:SEAR:MODE must be set to PARameter
ig you want Peak Search to take advantage of the threshold excursion.
Example: :CALC:MARK:PEAK:EXC 30 DB sets the minimum peak excursion
requirement to 30 dB.
See the full example for the CALC:MARK:PEAK:SEAR:MODE command
below.</Description>
            </Property>
            <Property>
               <Name>SAPeakThresh</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:CALC:MARK:PEAK:THR</ConfigureCommand>
                     <QueryCommand>:CALC:MARK:PEAK:THR?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the peak threshold value

4.1.8.2 Pk Threshold
Specifies the minimum signal level for the analyzer internal peak identification routine to
recognize as a peak. To be considered a peak, a signal must rise above the Peak Threshold
value by at least the value specified in Peak Excursn, then fall back down by at least the
Peak Excursn. This applies to all traces and all windows. Press ESC or select another active
function to hide the threshold line. Applies to Next Peak, Next Peak Left, and Next Peak Right.
If Peak Search is set to Param, it also applies to Peak Search.
Key Path: Peak Search, Search Param
Dependencies/
Couplings: This function is not available when Y-Axis is set to Frequency instead of
Amplitude.
State Saved: Saved in instrument state.
Factory Preset: 90 dBm
Terminators: dBmV, dBV, dB, V, W, A
Default Terminator: dBm
Resolution/
Rounding/
Truncation: .001 dBm
Knob Increment: amp scale = LOG: 1 % of dB/div or 0.01 (the larger of the two)
amp scale = LIN: 0.1 dBm
Step Key
Increment: amp scale = LOG: dB/div
amp scale = LIN:
Range: From the current reference level to the bottom of the display range
Remote Command:
:CALCulate:MARKer[1]|2|3|4:PEAK:THReshold &lt;ampl&gt;
:CALCulate:MARKer[1]|2|3|4:PEAK:THReshold?
Remote Command Notes: CALC:MARK:PEAK:SEAR:MODE must be set to PARameter if
you want peak search to take advantage of the threshold excursion.
Example: :CALC:MARK:PEAK:THR -60 dBm sets the threshold to -60 dBm.
See the full example for the CALC:MARK:PEAK:SEAR:MODE command
below.</Description>
            </Property>
            <Property>
               <Name>SAPresetType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:SYST:PRES:TYPE</ConfigureCommand>
                     <QueryCommand>:SYST:PRES:TYPE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="factory" Value="FACT"/>
                     <Enum Name="user" Value="USER"/>
                     <Enum Name="mode" Value="MODE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>mode</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the instrument preset mode.

4.9.2.2 Preset Type
Enables you to select what type of preset will be initiated when you press the green Preset
key or send the remote command, using SYST:PRES. Choose between Factory, Mode, or
User defined presets.
Key Path: System, Power On/Preset
State Saved: Survives Preset and power cycle, but is not saved in Instrument State.
SCPI Status Bits/
OPC Dependencies: None
Preset: Does not change the Preset Type.
Factory
Default: Mode
Remote Command:
:SYSTem:PRESet:TYPE FACTory|USER|MODE
:SYSTem:PRESet:TYPE?
Remote Command Notes: SYSTem:PRESet:USER:SAVE defines the user preset.
Example: SYST:PRES:TYPE FACT defines the type of preset as the factory preset.</Description>
            </Property>
            <Property>
               <Name>SARBWAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND:AUTO</ConfigureCommand>
                     <QueryCommand>:BAND:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth auto mode

See SpecRBW for more details
</Description>
            </Property>
            <Property>
               <Name>SATime</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

interface = get(obj, 'Interface');

time = query(interface, ':SYST:TIME?');

coma_idx = find(time == ',');

hour = time(1:coma_idx(1)-1);
minute = time(coma_idx(1)+1:coma_idx(2)-1);
sec = time(coma_idx(2)+1:end-1);

propertyValue = [hour 'h ' minute 'm ' sec 's'];</GetMCode>
                  <SetMCode>tyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>SATitle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:DISP:ANN:TITL:DATA</ConfigureCommand>
                     <QueryCommand>:DISP:ANN:TITL:DATA?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>No title</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or Queries the display title

2.5.5 Title
Displays menu keys that enable you to change or clear a title on your display.
Key Path: Display
2.5.5.1 Change Title
Allows you to write a title across the top of the display. Press Change Title to access the
Alpha Editor Menus that contain available characters and symbols. You may also use the
numeric keypad to enter numbers. Press Enter or Return to complete the entry. Press ESC to
cancel the entry and preserve your existing title.
The display title will remain until you press Change Title again, or you recall a trace or
state, or a
Factory Preset is performed. A title can also be cleared by pressing Title, Clear Title.
Pressing this key cancels any active function.
Key Path: Display, Title
State Saved: Saved in instrument state.
Remote Command:
:DISPlay:ANNotation:TITLe:DATA &lt;string&gt;
:DISPlay:ANNotation:TITLe:DATA?
Example: DISP:ANN:TITL:DATA This Is My Title</Description>
            </Property>
            <Property>
               <Name>SAVBWAuto</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>:BAND:VID:AUTO</ConfigureCommand>
                     <QueryCommand>:BAND:VID:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the resolution bandwidth auto mode

See Spec VBW for more info</Description>
            </Property>
            <Property>
               <Name>SpotOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand/>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>TRIGAUTOSTATE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>TRIG:AUTO:STAT</ConfigureCommand>
                     <QueryCommand>TRIG:AUTO:STAT?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the auto trigger.</Description>
            </Property>
            <Property>
               <Name>TRIGAUTOTIME</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>TRIG:AUTO</ConfigureCommand>
                     <QueryCommand>TRIG:AUTO?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1000.0" Min="0.1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the auto trigger time</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>BaseADCRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseAVG</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseAvgSetup</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseCOMPRESSDATA</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseDispEnable</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseFormat</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BasePRBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BasePreFFTfilt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseRBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseSpecData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseSPECPARAMS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>BaseWAVEPARAMS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>iGenAttenVals</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function AvailableAttenVals = iGenAttenVals(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
AvailableAttenVals = [0:2:70];</MCode>
               </Code>
               <Description>Returns Vector with all allowable Attenuation values</Description>
            </Method>
            <Method>
               <Name>iGenAutoCouple</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenAutoCouple(obj, WhichParm, AutoCplFlag, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Set optional inputs to false if they don't exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

interface = get(obj, 'interface');
InputValid = true;
switch WhichParm
  case 0 % Input Attenuation
    s = 'POW:ATT';
  case 1 % RBW
    s = 'BWID';
  case 2 %VBW
    s = 'BWID:VID';
  case 3 % Sweep time
    s = 'SWE:TIME';
  case 4 % Detector Mode
    s = 'DET';
  case 5 % average type
    s = 'AVER:TYPE';
  otherwise
    % warning input parm is invalid
    InputValid = false;
end
if InputValid
  fprintf(interface, [s, ':AUTO ', num2str(AutoCplFlag)]);
  if ChkResult &amp;&amp; RaiseError %Check to make sure it was set correctly
    out = str2double(query(interface, [s, ':AUTO?']));
    if out ~= AutoCplFlag
      error('SA:Function:AutoCouple:SettingIncorrect',...
        'The requested setting was not set as requested');
    end
  end
else
  if RaiseError
    error('SA:Function:AutoCouple:InvalidInput',...
      'The input parameter to set the auto couple feature was invalid');
  end
end</MCode>
               </Code>
               <Description>Sets the coupled status of the parameter designated by WhichParm to
the state designated by AutoCplFlag (1 = on, 0 = off)

WhichParm = 0 --&gt; Attenuation
WhichParm = 1 --&gt; RBW
WhichParm = 2 --&gt; VBW
WhichParm = 3 --&gt; Sweep Time
WhichParm = 4 --&gt; Detector
WhichParm = 5 --&gt; Video Average Type

If the optional input, RaiseError, = 1 then the auto couple state will be 
checked after it is set and an error will be raised. The default for this variable is false.</Description>
            </Method>
            <Method>
               <Name>iGenAutoCoupleAll</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenAutoCoupleAll(obj, AutoCplFlag, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Set optional inputs to false if they don't exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

% Set auto couple state for all parameters
interface = get(obj, 'interface');
if AutoCplFlag == true
  fprintf(interface, 'COUP ALL');
else
  for ii = 1:6
    invoke(obj, 'iGenAutoCouple', ii-1, 0, RaiseError);
  end
end

% if ChkResult and RaiseError = true check the setting and raise error if
% they are not correct
if ChkResult &amp;&amp; RaiseError
  for ii = 1:6
    State = invoke(obj, 'iGenQAutoCouple', ii-1, RaiseError);
    if State ~= AutoCplFlag
      error('SA:Function:AutoCoupleAll:SettingIncorrect',...
        ['The requested setting for couple parameter',num2str(ii-1),...
        ' was not set as requested']);
    end
  end
end
    </MCode>
               </Code>
               <Description>if AutoCplFlag = 1 then all parameters are auto coupled
if AutoCplFlag = 0 then auto coupling of all parameters is turnd off.

If RaiseError = true and ChkResult = true then the coupled state of all 
parameters are checked and an error is raised if any of them are not set properly.</Description>
            </Method>
            <Method>
               <Name>iGenCalNow</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenCalNow(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% set RaiseError to false if it does not exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

% get interface object
interface=get(obj,'interface');

% set timeout such that alignment has plenty of time.
set(interface,'Timeout',80);

% Perform alignment and wai for it to complete
out = str2double(query(interface, 'CAL?;*WAI'));

% check to make sure alignment completed properly
if RaiseError
  if out ~= 0
    error('SA:Function:CalNow:AlignFailed', 'The alignment failed');
  end
end

% Reset Timeout
set(interface, 'Timeout', 10);</MCode>
               </Code>
               <Description>This function forces the analyzer to do an alignment.

if RaiseError = true then an error will be raised if alignment is unsuccessful.</Description>
            </Method>
            <Method>
               <Name>iGenCFToMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenCFToMarker(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');
if MkrOrd &gt; 0 &amp;&amp; MkrOrd &lt;= 4
    fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':CENT']);      
else
  if RaiseError
    error('SA:Function:CFToMarker:InvalidInput',...
      'The input marker number is out of range. The center frequency has not been changed');
  end
end</MCode>
               </Code>
               <Description>This function sets the center frequency to the marker position.
Which marker is specified by MkrOrd.
If RaiseError = true this function will capture errors and report them. </Description>
            </Method>
            <Method>
               <Name>iGenDANL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Val = iGenDANL(obj, PreampOn, Freq, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');
[OptNums, ~] = invoke(obj, 'iGenQOptionsInstalled', RaiseError);
if ~PreampOn
  if Freq &gt;= 3 &amp;&amp; Freq &lt; 1e3
    Val = -110;
  elseif Freq &gt;= 1e3 &amp;&amp; Freq &lt; 10e3
    Val = -130;
  elseif Freq &gt;= 10e3 &amp;&amp; Freq &lt; 100e3
    Val = -141;
  elseif Freq &gt;= 100e3 &amp;&amp; Freq &lt; 1e6
    Val = -149;
  elseif Freq &gt;= 1e6 &amp;&amp; Freq &lt; 10e6
    Val = -153;
  elseif Freq &gt;= 10e6 &amp;&amp; Freq &lt; 1.2e9
    Val = -154;
  elseif Freq &gt;= 1.2e9 &amp;&amp; Freq &lt; 2.1e9
    Val = -153;
  elseif Freq &gt;= 2.1e9 &amp;&amp; Freq &lt; 6.6e9
    Val = -152;
  elseif Freq &gt;= 6.6e9 &amp;&amp; Freq &lt; 13.2e9 
    Val = -150;
  elseif Freq &gt;= 13.2e9 &amp;&amp; Freq &lt; 20e9
    Val = -147;
  elseif Freq &gt;= 20e9 &amp;&amp; Freq &lt;= 26.5e9
    Val = -143;
  else
    % Freq Out of Range
    Val = -145;
  end
else
  if ~isempty(intersect(OptNums, '110')) % upto 26.5 GHz 
    if Freq &gt;= 10e6 &amp;&amp; Freq &lt; 50e6
      Val = -154;
    elseif Freq &gt;= 50e6 &amp;&amp; Freq &lt; 500e6
      Val = -164;
    elseif Freq &gt;= 500e6 &amp;&amp; Freq &lt; 3e9
      Val = -168;
    elseif Freq &gt;= 3e9 &amp;&amp; Freq &lt; 6.6e9
      Val = -166;
    elseif Freq &gt;= 6.6e9 &amp;&amp; Freq &lt; 13.2e9
      Val = -165;
    elseif Freq &gt;= 13.2e9 &amp;&amp; Freq &lt; 16e9
      Val = -165;
    elseif Freq &gt;= 16e9 &amp;&amp; Freq &lt; 19e9 
      Val = -164;
    elseif Freq &gt;= 19e9 &amp;&amp; Freq &lt;= 26.5e9
      Val = -161;
    else
      % Freq Out of Range
      Val = -130;
    end
  elseif ~isempty(intersect(OptNums, '1DS')) % up to 3 GHz 
    if Freq &gt;= 100e3 &amp;&amp; Freq &lt; 500e3
      Val = -162;
    elseif Freq &gt;= 500e3 &amp;&amp; Freq &lt; 1e6
      Val = -163;
    elseif Freq &gt;= 1e6 &amp;&amp; Freq &lt; 10e6
      Val = -168;
    elseif Freq &gt;= 10e6 &amp;&amp; Freq &lt; 500e6
      Val = -170;
    elseif Freq &gt;= 500e6 &amp;&amp; Freq &lt; 1.1e9
      Val = -169;
    elseif Freq &gt;= 1.1e9 &amp;&amp; Freq &lt; 2.1e9
      Val = -168;
    elseif Freq &gt;= 2.1e9 &amp;&amp; Freq &lt;= 3e9 
      Val = -166;
    else
      % Freq Out of Range
      Val = -130;
    end
  else %No Preamp
    if Freq &gt;= 3 &amp;&amp; Freq &lt; 1e3
      Val = -110;
    elseif Freq &gt;= 1e3 &amp;&amp; Freq &lt; 10e3
      Val = -130;
    elseif Freq &gt;= 10e3 &amp;&amp; Freq &lt; 100e3
      Val = -141;
    elseif Freq &gt;= 100e3 &amp;&amp; Freq &lt; 1e6
      Val = -149;
    elseif Freq &gt;= 1e6 &amp;&amp; Freq &lt; 10e6
      Val = -153;
    elseif Freq &gt;= 10e6 &amp;&amp; Freq &lt; 1.2e9
      Val = -154;
    elseif Freq &gt;= 1.2e9 &amp;&amp; Freq &lt; 2.1e9
      Val = -153;
    elseif Freq &gt;= 2.1e9 &amp;&amp; Freq &lt; 6.6e9
      Val = -152;
    elseif Freq &gt;= 6.6e9 &amp;&amp; Freq &lt; 13.2e9 
      Val = -150;
    elseif Freq &gt;= 13.2e9 &amp;&amp; Freq &lt; 20e9
      Val = -147;
    elseif Freq &gt;= 20e9 &amp;&amp; Freq &lt;= 26.5e9
      Val = -143;
    else
      % Freq Out of Range
      Val = -145;
    end
  end
end

    </MCode>
               </Code>
               <Description>Gets the DANL value based on frequency and whether or not preamp is on.</Description>
            </Method>
            <Method>
               <Name>iGenDeltaMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenDeltaMarker(obj, MkrOrd, DeltaVal, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

interface = get(obj, 'interface');
if MkrOrd &gt; 0 &amp;&amp; MkrOrd &lt;= 4
  % Make sure specified marker is in delta mode
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':MODE DELT']);

  % Move the delta marker the specified value from the reference marker
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':X ',num2str(DeltaVal)]);
else
  if RaiseError
    error('SA:Function:DeltaMarker:InvalidInput','The specified marker number is out of range');
  end
end

% Check to make sure it was set correctly if RaiseError = ChkResult = true.
if ChkResult &amp;&amp; RaiseError
  SetDelta = invoke(obj, 'iGenQMarkerDelta', MkrOrd, RaiseError);
  if ~WithinTol(SetDelta, DeltaVal, .1)
    error('SA:Function:DeltaMarker:SettingIncorrect',...
      'The marker delta has not been set as requested.');
  end
end</MCode>
               </Code>
               <Description>This sets a delta marker on the screen at the specified frequency difference (or time difference in zero span).
If RaiseError = true an error is raised if a invlaid input is entered.
If ChkResult = RaiseError = true the marker delta value is checked to make sure it was set properly. If it was not an error is raised.

This function works oddly. For best results use iGenMarkerToFreq to move a marker to a reference point and then use this
function to move the delta marker to the specified delta.</Description>
            </Method>
            <Method>
               <Name>iGenFreqInRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function InRange = iGenFreqInRange(obj, WhichFreq, FreqValue, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

if ~exist('RaiseError', 'var')
  RaiseError = false;
end

Range = invoke(obj, 'iGenFreqRange', WhichFreq, RaiseError);
if ~isempty(Range)
  Min = Range(1);
  Max = Range(2);
  if FreqValue &gt;= Min &amp;&amp; FreqValue &lt;= Max
    InRange = true;
  else
    InRange = false;
  end
else
  InRange = false;
end</MCode>
               </Code>
               <Description>queries the analyzer to determine if the specified frequency value is within the limits of the specified frequency type.
WhichFreq = 1 --&gt; Center Freq
WhichFreq = 2 --&gt; Start Freq
WhichFreq = 3 --&gt; Stop Freq
WhichFreq = 4 --&gt; Span
WhichFreq = 5 --&gt; Freq Offset
WhichFreq = 6 --&gt; RBW
WhichFreq = 7 --&gt; VBW

FreqValue is specified in hertz
If RaiseError = true this functions will raise error to be caught at measurement level</Description>
            </Method>
            <Method>
               <Name>iGenFreqRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Range = iGenFreqRange(obj, WhichFreq, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface= get(obj, 'interface');
ValidInput = true;
switch WhichFreq
  case 1 % Center Freq
    s = ':FREQ:CENT?';
  case 2 % Start Freq
    s = ':FREQ:STAR?';
  case 3 % Stop Freq
    s = ':FREQ:STOP?';
  case 4 % Span
    s = ':FREQ:SPAN?';
  case 5 %Offset
    s = ':FREQ:OFFS?';
  case 6 % RBW
    s = ':BWID?';
  case 7 % VBW
    s = ':BWID:VID?';
  otherwise %invalid input
    % warning invalid input
    ValidInput = false;
    Range = [];
end
if ValidInput
  MinFreq = str2double(query(interface, [s, ' MIN']));
  MaxFreq = str2double(query(interface, [s, ' MAX']));
  Range = [MinFreq MaxFreq];
else
  if RaiseError
    error('SA:Function:FreqRange:InvalidInput',...
      'The input parameter to query the frequency range is invalid');
  end
  Range = [];
end</MCode>
               </Code>
               <Description>queries the min and max of a the frequency specified by WhichFreq
WhichFreq = 1 --&gt; Center Freq
WhichFreq = 2 --&gt; Start Freq
WhichFreq = 3 --&gt; Stop Freq
WhichFreq = 4 --&gt; Span
WhichFreq = 5 --&gt; Freq Offset
WhichFreq = 6 --&gt; RBW
WhichFreq = 7 --&gt; VBW

If RaiseError = true errors will be raised for Visa Read errors or invalid input for WhichFreq.</Description>
            </Method>
            <Method>
               <Name>iGenGetOvrDrvAndAlignRqst</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OverLoadFlag, AlignFlag] = iGenGetOvrDrvAndAlignRqst(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.


interface=get(obj,'interface');

% check for alignment
temp = str2double(query(interface, 'STAT:QUES:CAL:COND?'));
if temp &gt; 0
  AlignFlag = true;
else
  AlignFlag = false;
end

% check for Overload
temp1 = str2double(query(interface, 'STAT:QUES:INT:COND?'));
temp2 = str2double(query(interface, 'STAT:QUES:POW:COND?'));

IF2OverLoad = bitand(uint16(temp1), uint16(16));
IF1OverLoad = bitand(uint16(temp2), uint16(64));

if IF2OverLoad == 16 || IF1OverLoad == 64
  OverLoadFlag = true;
else
  OverLoadFlag = false;
end

</MCode>
               </Code>
               <Description>Query status registers to determine whether or not an overload has occurred or an alignment is required.
If RaiseError = true Visa read errors will be captured and reported.</Description>
            </Method>
            <Method>
               <Name>iGenGetTraceDet</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Det = iGenGetTraceDet(obj, TraceOrd, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
Det = get(obj, 'iGenDetector');</MCode>
               </Code>
               <Description>The E4440 does not support different detectors on traces so this is the same as iGenDetector or iGenDetectorChkResult depending on ChkResult input.
</Description>
            </Method>
            <Method>
               <Name>iGenMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenMarker(obj, MkrOrd, TurnMarkerOn, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Create RaiseError and/or ChkResult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

interface = get(obj, 'interface');

% Only do selected marker if in range (the E4440 allows up to 4 markers).
if MkrOrd &gt;= 0 &amp;&amp; MkrOrd &lt;= 4
  if TurnMarkerOn
    if MkrOrd == 0
      for ii = 1:4
        fprintf(interface, ['CALC:MARK',num2str(ii),':STAT ON']);
      end
    else
      fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':STAT ON']);
    end
  else
    if MkrOrd == 0
      s = ':AOFF';
    else
      s = [num2str(MkrOrd),':STAT OFF'];
    end
    fprintf(interface, ['CALC:MARK', s]);
  end
else
  if RaiseError
    error('SA:Function:Marker:InvalidInput','The input marker number is out of range');
  end
end
% Check the setting and report error is wrong if RaiseError = ChkResult =
% false.
ItWorked = true;
if ChkResult &amp;&amp; RaiseError
  if MkrOrd == 0
    for ii = 1:4
      MarkerState = str2double(query(interface, ['CALC:MARK',num2str(ii),':STAT?']));
      if MarkerState ~= TurnMarkerOn
        ItWorked = false;
      end
    end
  else
    MarkerState = str2double(query(interface, ['CALC:MARK',num2str(MkrOrd),':STAT?']));
    if MarkerState ~= TurnMarkerOn
      ItWorked = false;
    end
  end
  if ~ItWorked
    error('SA:Function:Marker:SettingIncorrect',...
      'The marker state has not been set as requested');
  end
end</MCode>
               </Code>
               <Description>Turns the specified marker on or off
if 0 is the specified marker then all markers are affected
MkrOrd = specified marker
TurnMarkerOn = marker state true = on false = off

if RaiseError = true an error may be raised should one occur.
ChkResult = RaiseError = true then the setting will be checked and 
an error will be raised if it is not correct.</Description>
            </Method>
            <Method>
               <Name>iGenMarkerMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenMarkerMode(obj, MkrOrd, MkrMode, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Set optional inputs to false if they don't exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

interface = get(obj, 'interface');
ValidInput = true;
switch MkrMode
  case 0 %off
    ModeStr = ':MODE OFF';
  case 1 %Normal
    ModeStr = ':MODE POS';
  case 2 %Delta
    ModeStr = ':MODE DELT';
  case 3 % Band Power
    ModeStr = ':MODE BAND';
  case 4 % Span
    ModeStr = ':MODE SPAN';
  otherwise % invalid input
    % warning invalid input raise flag
    ValidInput = false;
end
% only attempt to set the marker if a valid mode and number has been selected
if ValidInput &amp;&amp; MkrOrd &gt; 0 &amp;&amp; MkrOrd &lt;= 4
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),ModeStr]);
else
  if RaiseError
    if ValidInput
      error('SA:Function:MarkerMode:InvalidInput','The input marker number is out of range');
    else
      error('SA:Function:MarkerMode:InvalidInput','The input marker mode is not valid');
    end
  end
end

% If ChkResult = RaiseError = true check the mode setting to make sure it
% has been set properly.
if RaiseError &amp;&amp; ChkResult
  [SetMode, ~] = invoke(obj, 'iGenQMarkerMode', MkrOrd, RaiseError);
  if SetMode ~= MkrMode
    error('SA:Function:MarkerMode:SettingIncorrect', 'The marker mode has not been set as requested');
  end
end</MCode>
               </Code>
               <Description>This Function sets the specified marker (MkrOrd) mode designated by MkrMode.
Modes Are:
0 = off
1 = normal
2 = delta
3 = band power
4 = span

There is a difference between marker state and marker mode. A marker may be in a non-off mode,
but still not be displayed if its state is off.

If RaiseError = true then errors will be raised for invlaid inputs.
If ChkREsult = RaiseError = true then an error will be raised if the setting is not set as requested.</Description>
            </Method>
            <Method>
               <Name>iGenMarkerToFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenMarkerToFreq(obj, MkrOrd, FreqVal, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Create RaiseError and/or ChkREsult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

interface = get(obj, 'interface');
% check to make sure marker number is in range
if MkrOrd &gt; 0 &amp;&amp; MkrOrd &lt;= 4
  % Make sure specified marker is in Normal mode
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':MODE POS']);
  
  % Move marker to specified frequency
  fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':X ',num2str(FreqVal)]);
else
  if RaiseError
    error('SA:Function:MarkerToFreq:InvalidInput','The input marker number is out of range');
  end
end

% if ChkResult = RaiseError = true then check to see if this was set
% correctly
if ChkResult &amp;&amp; RaiseError
  MarkerFreq = invoke(obj, 'iGenQMarkerFreq', MkrOrd, RaiseError);
  if ~WithinTol(MarkerFreq, FreqVal, .1)
    error('SA:Function:MarkerToFreq:SettingIncorrect','The marker has not been set to the requested frequency');
  end
end</MCode>
               </Code>
               <Description>Moves Marker to spescified frequency. Only works for markers in normal mode. This function 
will automatically put the specified marker in normal mode.

If RaiseError = true then errors will be raised for invlaid inputs.
If ChkREsult = RaiseError = true then an error will be raised if the setting is not set as requested.</Description>
            </Method>
            <Method>
               <Name>iGenMarkerToPeak</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenMarkerToPeak(obj, MkrOrd, DetMode, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');
ValidInput = true;
switch DetMode
  case 0 % max peak
    str = '';
  case 1 % next highest
    str = ':NEXT';
  case 2 % next Right
    str = ':RIGH';
  case 3 % Next Left
    str = ':LEFT';
  otherwise
    % warning invalid input
    ValidInput = false;
end
if ValidInput &amp;&amp; MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':MAX',str]);
else
  if RaiseError
    if ValidInput
      error('SA:Function:MarkerMode:InvalidInput','The input marker number is out of range.');
    else
      error('SA:Function:MarkerMode:InvalidInput','The input marker detector mode is not valid. Must be 0-3.');
    end
  end
end</MCode>
               </Code>
               <Description>places a marker at the highest peak the next highest peak, the next right peak, or the next left peak

If RaiseError = true then errors will be raised for invlaid inputs.</Description>
            </Method>
            <Method>
               <Name>iGenNumMarkerModes</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumModes, ModeNames] = iGenNumMarkerModes(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
NumModes = 5;
ModeNames = {'Off', 'Normal', 'Delta', 'Band-Power', 'Span'};</MCode>
               </Code>
               <Description>returns the number of available marker modes and the names of those marker modes.</Description>
            </Method>
            <Method>
               <Name>iGenNumTraceModes</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [NumModes, ModeNames] = iGenNumTraceModes(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
NumModes = 5;
ModeNames = {'Clear Write', 'Max Hold', 'Min Hold', 'View', 'Blank'};</MCode>
               </Code>
               <Description>returns the number of trace modes and the names of each.
</Description>
            </Method>
            <Method>
               <Name>iGenNumTraces</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Num, IDs] = iGenNumTraces(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
Num = 3;
IDs = {'Trace 1'; 'Trace 2'; 'Trace 3'};</MCode>
               </Code>
               <Description>returns the number of traces and the ID for each</Description>
            </Method>
            <Method>
               <Name>iGenOptionNames</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [OptionID, OptionNames] = iGenOptionNames(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
OptionID = {'110', '122', '123', '124', '1DS', '202', '204', '210', '211', '214',...
  '215', '219', '226', '241', '266', 'AYZ', 'B78', 'B7J', 'BAB', 'BAC',...
  'BAE', 'BAF', 'H70'};
OptionNames = {'100 kHz to 50 GHz Built-in Preamplifier', '80 MHz Bandwidth Digitizer', 'Switchable MW Preselector Bypass',...
  'Y-Axis Video Ouput', '100 kHz to 3 GHz Built-in Preamplifier', 'GSM w/EDGE',...
  '1xEV-DO', 'HSDPA', 'TD-SCDMA', '1xEV-DV', 'External Source Control',...
  'Noise Figure', 'Phase Noise', 'Flexible Modulation Analysis', '8566 Compatibility',...
  'External Mixing', 'CDMA2000', 'Digital Demodulation Hardware', 'APC 3.5 Connector',...
  'CDMAOne', 'NADC, PCD', 'W-CDMA for 3GPP', '70 MHz IF Output'};</MCode>
               </Code>
               <Description>Returns the option ID numbers and their associated names. Indexes are mathced in the two vectors.</Description>
            </Method>
            <Method>
               <Name>iGenPeakTracePnt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [freq, amp] = iGenPeakTracePnt(obj, NewTrace)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% get sweep time for use later
ST = str2double(query(interface, 'SWE:TIME?'));

% set Time out to 1 minute to account for sweep start delay
set(interface, 'TimeOut', 60);

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

% Set the analyzer into single sweep mode
fprintf(interface,':INIT:CONT OFF');

% Trigger the sweep and wait for it to complete if a new sweep is requested
if NewTrace
  fprintf(interface,':INIT:IMM');
  if ST &gt; 12
    pause(ST - 2);
  end
  query(interface, '*OPC?');
end

% Get the peak data back
fprintf(interface, ':CALC:MARK:MODE POS');
fprintf(interface,':CALC:MARK:MAX');
freq = str2double(query(interface,':CALC:MARK:X?'));
amp = str2double(query(interface,':CALC:MARK:Y?'));

% Reset timeout
set(interface,'Timeout',10);
</MCode>
               </Code>
               <Description>This function queries the maximum trace point of the active trace and puts a marker on it.
It returns the frequency and magnitude of the point.

NewTrace tells the function to take a new trace before finding the peak.</Description>
            </Method>
            <Method>
               <Name>iGenPreampBand</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenPreampBand(obj, State, Band, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Create RaiseError and/or ChkREsult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

% Set the state of the preamp
IFace = get(obj, 'interface');
fprintf(IFace, [':POW:GAIN ',num2str(State)])

% check the setting
if RaiseError &amp;&amp; ChkResult
  SetState = str2double(query(IFace, ':POW:GAIN?'));
  if SetState ~= State
    error('SA:Function:PreampBand:SettingIncorrect', 'The premap state has not been set as requested.');
  end
end</MCode>
               </Code>
               <Description>This function is primarily for the PXA only. For the E4440 this function does the same thing as the iGenIntPreamp property</Description>
            </Method>
            <Method>
               <Name>iGenPreset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <Line Command="*RST" Output="false"/>
                  </Commands>
               </Code>
               <Description>This function presets the analyzer</Description>
            </Method>
            <Method>
               <Name>iGenQAutoCouple</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function CoupleState = iGenQAutoCouple(obj, WhichParm, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interfaceObj = get(obj, 'interface');

InputValid = true;
switch WhichParm
  case 0 % Input Attenuation
    s = 'POW:ATT';
  case 1 % RBW
    s = 'BWID';
  case 2 %VBW
    s = 'BWID:VID';
  case 3 % Sweep time
    s = 'SWE:TIME';
  case 4 % Detector Mode
    s = 'DET';
  case 5 % average type
    s = 'AVER:TYPE';
  otherwise
    % warning input parm is invalid
    InputValid = false;
end

if InputValid
  CoupleState = str2double(query(interfaceObj, [s, ':AUTO?']));
else
  if RaiseError
    error('SA:Function:QAutoCouple:InvalidInput',...
      'Input argument, WhichParm, is invalid');
  end
end</MCode>
               </Code>
               <Description>Queries the auto couple state of the input parameter designated by WhichParm.

WhichParm = 0 --&gt; Attenuation
WhichParm = 1 --&gt; RBW
WhichParm = 2 --&gt; VBW
WhichParm = 3 --&gt; Sweep Time
WhichParm = 4 --&gt; Detector
WhichParm = 5 --&gt; Video Average Type

If RaiseError = true an error will be raised if there is an error.</Description>
            </Method>
            <Method>
               <Name>iGenQFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function FreqVal = iGenQFreq(obj, WhichFreq, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interfaceObj = get(obj, 'interface');

% Look up which SCPI command to use.
ValidInput = true;
switch WhichFreq
  case 1 % Center Freq
    s = ':FREQ:CENT?';
  case 2 % Start Freq
    s = ':FREQ:STAR?';
  case 3 % Stop Freq
    s = ':FREQ:STOP?';
  case 4 % Span
    s = ':FREQ:SPAN?';
  case 5 %Offset
    s = ':FREQ:OFFS?';
  case 6 % RBW
    s = ':BWID?';
  case 7 % VBW
    s = ':BWID:VID?';
  otherwise %invalid input
    % warning invalid input
    ValidInput = false;
end

% if valid input query the relevant frequency value.
if ValidInput
  FreqVal = str2double(query(interfaceObj, s));
else
  if RaiseError
    error('SA:Function:QFreq:InvalidInput', 'Entered value for WhichFreq is invalid');
  end
  FreqVal = [];
end</MCode>
               </Code>
               <Description>This function queries the freqeuncy designated by WhichFreq. 

Allowed inputs are:
1 = Center Frequency
2 = Start Frequency
3 = Stop Frequency
4 = Span
5 = CF Offset
6 = RBW
7 = VBW

If RaiseError = true an error will be raised if the input is not valid.
If not true and error occurs then FreqVal will be empty.</Description>
            </Method>
            <Method>
               <Name>iGenQMarkerAmp</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function MarkerAmp = iGenQMarkerAmp(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');

if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  MarkerAmp = str2double(query(interface, [':CALC:MARK', num2str(MkrOrd), ':Y?']));
else
  if RaiseError
    error('SA:Function:QMarkerAmp:InvalidInput','The input marker number is out of range. must be 1-4.');
  end
  MarkerAmp = [];
end</MCode>
               </Code>
               <Description>queries the amplitude of the specified marker

If RaiseError = true an error will be raised if there is an error.</Description>
            </Method>
            <Method>
               <Name>iGenQMarkerDelta</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function DeltaVal = iGenQMarkerDelta(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'iGenQMarkerMode', MkrOrd, RaiseError);
  if ModeNum == 2 % delta
    DeltaVal = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X?']));
  else
   if RaiseError
      error('SA:Function:QMarkerDelta:WrongMode','The designated marker must be in delta mode to read the delta value.');
    end
    DeltaVal = [];
  end
else
  if RaiseError
    error('SA:Function:QMarkerDelta:InvalidInput','The input marker number is out of range. Must be 1-4.');
  end
  DeltaVal = [];
end</MCode>
               </Code>
               <Description>Queries the distance between markers must be in delta mode.

If RaiseError = true an error will be raised if there is an error.</Description>
            </Method>
            <Method>
               <Name>iGenQMarkerFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Freq = iGenQMarkerFreq(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'iGenQMarkerMode', MkrOrd);
  if ModeNum == 1 % Normal
    Freq = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X?']));
  else
    if RaiseError
      error('SA:Function:QMarkerFreq:WrongMode','The designated marker must be in normal mode to read the freqeuncy value');
    end
    Freq = [];
  end
else
  if RaiseError
    error('SA:Function:QMarkerFreq:InvalidInput','The input marker number is out of range. Must be 1-4.');
  end
  Freq = [];
end</MCode>
               </Code>
               <Description>queries the frequncy value of the currnet marker must be in normal mode.

If RaiseError = true an error will be raised if there is an error.</Description>
            </Method>
            <Method>
               <Name>iGenQMarkerMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MkrModeNum, MkrModeName] = iGenQMarkerMode(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');

if MkrOrd &gt; 0 &amp;&amp; MkrOrd &lt;= 4
  % check to see if marker is on. Once Marker is turned on the mode is
  % preserved and never returns to off. On/off can only truly be determined
  % using the STAT command.
  MarkerState = str2double(query(interface, ['CALC:MARK',num2str(MkrOrd),':STAT?']));
  if MarkerState
    temp = deblank(query(interface, [':CALC:MARK',num2str(MkrOrd),':MODE?']));
  else
    temp = 'OFF';
  end
  switch temp
    case 'OFF'
      MkrModeNum = 0;
      MkrModeName = 'Off';
    case 'POS'
      MkrModeNum = 1;
      MkrModeName = 'Normal';
    case 'DELT'
      MkrModeNum = 2;
      MkrModeName = 'Delta';
    case 'BAND'
      MkrModeNum = 3;
      MkrModeName = 'Band-Power';
    case 'SPAN'
      MkrModeNum = 4;
      MkrModeName = 'Span';
    otherwise %Invalid reply from analyzer
      if RaiseError
        error('SA:Function:QMarkerMode:ReadError','An invalid value was returned from the instrument');
      end
      MkrModeNum = [];
      MkrModeName = {};
  end
else % MkrOrd not in range
  if RaiseError
    error('SA:Function:QMarkerMode:InvalidInput','The input marker number is out of range');
  end
  MkrModeNum = [];
  MkrModeName = {};
end</MCode>
               </Code>
               <Description>This functions queries the marker mode for the marker designated by MkrOrd.
It returns both the mode number and the mode name.
If RaiseError = true an error will be raised if one occurrs, If RaiseError = false
and an error occurs this function will return an empty set [] for the mode number
and an empty cell {} for the mode name.

Modes:
0 = off
1 = normal
2 = delta
3 = band power
4 = span</Description>
            </Method>
            <Method>
               <Name>iGenQMeasModesInstalled</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MeasModeName, MeasModeInstrVal] = iGenQMeasModesInstalled(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

PotentialMeasModes = {'SA', 'CDMA', 'NADC', 'PDC', 'BASIC', 'WCDMA',...
  'CDMA2K', 'EDGEGSM', 'PNOISE', 'CDMS1XEV', 'WLAN', 'NFIGURE',...
  'LINK', 'MRECEIVE', 'DMODULATION', 'TDSCDMA'};

% get mode names from property iGenMeasMode
out = propinfo(obj, 'iGenMeasMode');
PotentialModeNames = out.ConstraintValue';

InstalledModes = query(interface, 'INST:CAT?');
idx = [];
for ii = 1:length(PotentialMeasModes)
  if ~isempty(findstr(PotentialMeasModes{ii}, InstalledModes))
    idx = [idx ii];
  end
end

MeasModeName = PotentialModeNames(idx);
MeasModeInstrVal = PotentialMeasModes(idx);</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>iGenQMkrPntPos</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function PointPosition = iGenQMkrPntPos(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');

if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
  [ModeNum, ~] = invoke(obj, 'iGenQMarkerMode', MkrOrd);
  if ModeNum == 1 % Normal
    PointPosition = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS?']));
  elseif ModeNum == 2 % Delta This doesn't work
    RefPoint = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS:STAR?']));
    DeltaPoint = str2double(query(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS:STOP?']));
    PointPosition = [RefPoint DeltaPoint];
  else
    if RaiseError
      error('SA:Function:QMkrPntPos:WrongMode',...
        'The designated marker must be in normal or delta mode to read the point position');
    end
    PointPosition = [];
  end
else
  if RaiseError
    error('SA:Function:QMkrPntPos:InvalidInput',...
      'The input marker number is out of range. Must be 1-4.');
  end
  PointPosition = [];
end</MCode>
               </Code>
               <Description>returns the point position of the marker also returns the position of the delta and ref markers if delta mode. 

This function does not work for Delta mode, as the SCPI commands for finding ref and delta positions do not work as stated in the E4440 Manual
It will work for markers in normal mode.

If RaiseError = true an error will be raised if the input is not valid.
If not true and error occurs then PointPosition will be empty.</Description>
            </Method>
            <Method>
               <Name>iGenQOptionsInstalled</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [AvailOptIDs, AvailOptNames] = iGenQOptionsInstalled(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');

InstalledOpts = query(interface, 'SYST:OPT?');
[OptionID, OptionNames] = invoke(obj, 'iGenOptionNames');

idx = [];
for ii = 1:length(OptionID)
  if ~isempty(findstr(InstalledOpts, OptionID{ii}))
    idx = [idx ii];
  end
end
AvailOptIDs = OptionID(idx);
AvailOptNames = OptionNames(idx);
</MCode>
               </Code>
               <Description>Query which options are available on the E4440 Currently in use</Description>
            </Method>
            <Method>
               <Name>iGenQTraceMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [ModeNum, ModeName] = iGenQTraceMode(obj, TraceOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

% get number of available traces and trace mode names and interface.
[NumTraces, ~] = invoke(obj, 'iGenNumTraces');
[~, ModeNames] = invoke(obj, 'iGenNumTraceModes');
interface = get(obj, 'interface');

PotentialModes = {'WRIT', 'MAXH', 'MINH', 'VIEW', 'BLAN'};

if TraceOrd &gt;= 1 &amp;&amp; TraceOrd &lt;= NumTraces
  temp = deblank(query(interface, [':TRAC',num2str(TraceOrd),':MODE?']));
  [~, ~, temp2] = intersect(temp, PotentialModes);
  ModeNum = temp2-1;
  if ModeNum+1 &gt;= 1 &amp;&amp; ModeNum+1 &lt;= length(ModeNames)
    ModeName = ModeNames{ModeNum+1};
  else
    if RaiseError
      error('SA:Function:QTraceMode:InvalidReturnVal',...
        'The spectrum analyzer returned a bad value for trace mode.');
    end
    ModeNum = [];
    ModeName = {};
  end
else
  if RaiseError
    error('SA:Function:QTraceMode:InvalidInput',...
      ['The input trace number is invalid. Must be 1-',num2str(NumTraces),'.']);
  end
  ModeNum = [];
  ModeName = {};
end

</MCode>
               </Code>
               <Description>queries the SA for the mode of the specified trace. It returns both the mode number and the mode name.

Modes
0 = Clear Write
1 = Max Hold
2 = Min Hold
3 = View
4 = Blank

If RaiseError = true an error will be raised should one occur.</Description>
            </Method>
            <Method>
               <Name>iGenQuerySCPI</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function res=iGenQuerySCPI(obj,cmd)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

interface=get(obj,'interface');

res=query(interface,cmd);</MCode>
               </Code>
               <Description>Query_SCPI sends an SCPI string to the instrument and returns its response.

Input parameters: SCPI string
Output parameters: response string from the instrument</Description>
            </Method>
            <Method>
               <Name>iGenQuickCalNow</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenQuickCalNow(obj, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% set RaiseError to false if it does not exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

invoke(obj, 'iGenCalNow', RaiseError);</MCode>
               </Code>
               <Description>This functions performs a quick cal if possible. If one is not possible it performs a full alignment.
For the E4440 this is not possible so a full alignment will be performed when this funciton is called.</Description>
            </Method>
            <Method>
               <Name>iGenRefLevelToMarker</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenRefLevelToMarker(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');
if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':RLEV']);
else
  if RaiseError
     error('SA:Function:MarkerMode:InvalidInput','The input marker mode is not valid. Must be 1-4.');
  end
end</MCode>
               </Code>
               <Description>sets the reference level to the amplitude of the specified marker

If RaiseError = true an error will be raised if an invalid input is entered.</Description>
            </Method>
            <Method>
               <Name>iGenSetFreq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetFreq(obj, WhichFreq, FreqValue, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Create RaiseError and/or ChkREsult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

interface = get(obj, 'interface');

% Check to make sure freq value is in range
if invoke(obj, 'iGenFreqInRange', WhichFreq, FreqValue, RaiseError)
  ValidInput = true;
  switch WhichFreq
    case 1 % Center Freq
      s = ':FREQ:CENT ';
    case 2 % Start Freq
      s = ':FREQ:STAR ';
    case 3 % Stop Freq
      s = ':FREQ:STOP ';
    case 4 % Span
      s = ':FREQ:SPAN ';
    case 5 %Offset
      s = ':FREQ:OFFS ';
    case 6 % RBW
      s = ':BWID ';
    case 7 % VBW
      s = ':BWID:VID ';
    otherwise %invalid input
      % warning invalid input
      ValidInput = false;
  end
  if ValidInput
    fprintf(interface, [s, num2str(FreqValue)]);
    Freq = str2double(query(interface, [s(1:end-1),'?']));
    if RaiseError &amp;&amp; ChkResult
      if ~WithinTol(Freq, FreqValue, .01)
        error('SA:Function:SetFreq:SettingIncorrect',...
          'The Frequency specified by WhichFreq was not set as requested');
      end
    end
  else
    if RaiseError
      error('SA:Function:SetFreq:InvalidInput',...
        'The input parameter, WhichFreq, to set the frequency is invalid');
    end
  end
else
  % warning specified frequency is not within the allowable range.
  if RaiseError
    error('SA:Function:SetFreq:InvalidInput',...
      'The input parameter, FreqValue, is out of range');
  end
end</MCode>
               </Code>
               <Description>Sets the specified frequency (WhichFreq) type to the specified value (FreqValue).
WhichFreq = 1 --&gt; Center Freq
WhichFreq = 2 --&gt; Start Freq
WhichFreq = 3 --&gt; Stop Freq
WhichFreq = 4 --&gt; Span
WhichFreq = 5 --&gt; Freq Offset
WhichFreq = 6 --&gt; RBW
WhichFreq = 7 --&gt; VBW

FreqValue is specified in hertz
if RaiseError = true then errors will be raised for invlaid inputs.
If ChkREsult = RaiseError = true then an error will be raised if the setting is not set as requested.</Description>
            </Method>
            <Method>
               <Name>iGenSetMkrByPnt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetMkrByPnt(obj, MkrOrd, TracePnt, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
% Set optional inputs to false if they don't exist
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

% Make sure tracePnt is an integer, read the current number of points, and
% get the interface.
RoundedTracePnt = round(TracePnt);
if RoundedTracePnt ~= TracePnt
  if RaiseError
    error('SA:Function:SetMkrByPnt:InvalidInput','The input TracePnt must be an integer.');
  else
    TracePnt = RoundedTracePnt;
  end
end
NumPoints = get(obj, 'iGenSweepPoints');
interface = get(obj, 'interface');

if TracePnt &lt;= NumPoints
  if MkrOrd &lt;= 4 &amp;&amp; MkrOrd &gt;= 1
    [ModeNum, ~] = invoke(obj, 'iGenQMarkerMode', MkrOrd);
    if ModeNum == 1 % Normal
      fprintf(interface, [':CALC:MARK',num2str(MkrOrd),':X:POS ',num2str(TracePnt)]);
    else
      if RaiseError
        error('SA:Function:SetMkrByPnt:WrongMode','The designated marker must be in normal mode.');
      end
    end
  else
    if RaiseError
      error('SA:Function:SetMkrByPnt:InvalidInput','The input marker number is out of range. Must be 1-4.');
    end
  end
else
  if RaiseError
    error('SA:Function:SetMkrByPnt:InvalidInput',['The input trace point number must be less then the number of sweep points (',...
      num2str(NumPoints),').']);
  end
end

% Check the setting if ChkResult = RaiseError = true.
if ChkResult &amp;&amp; RaiseError
  MkrPntPos = invoke(obj, 'iGenQMkrPntPos', MkrOrd, RaiseError);
  if MkrPntPos ~= TracePnt
    error('SA:Function:SetMkrByPnt:SettingIncorrect','The marker has not been set to the requested point');
  end
end</MCode>
               </Code>
               <Description>sets the position of the specified marker (MkrOrd) in normal mode to the point position specified (TracePnt). 
TracePnt must be an integer. If it is not an integer and RaiseError = false it will be rounded to the nearest integer.
If RaiseError = true an error will be raised.

This function only works on markers in normal mode.

if RaiseError = true then errors will be raised for invlaid inputs.
If ChkREsult = RaiseError = true then an error will be raised if the setting is not set as requested.</Description>
            </Method>
            <Method>
               <Name>iGenSetOvrDrvAndAlignRqst</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetOvrDrvAndAlignRqst(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Get interface obj
interface=get(obj,'interface');

% set decimal representations of status bits
AlignRqst = 16384;
OvrDrv = 16; %Second IF Overload
FstIFOvrDrv = 64; % First IF Overdive
AllBits = 32767;
NoBits = 0;

% SCPI Command headers
Hdr1 = 'STAT:QUES:CAL:';
Hdr2 = 'STAT:QUES:INT:';
% Send commands to Analyzer to set up status registers
fprintf(interface,[Hdr1, 'PTR ', num2str(AlignRqst)]);
fprintf(interface,[Hdr1, 'NTR ', num2str(NoBits)]);
fprintf(interface,[Hdr1, 'ENAB ', num2str(AlignRqst)]);
fprintf(interface,[Hdr2, 'PTR ', num2str(OvrDrv+FstIFOvrDrv)]);
fprintf(interface,[Hdr2, 'NTR ', num2str(NoBits)]);
fprintf(interface,[Hdr2, 'ENAB ', num2str(AllBits)]);

% Clear questionable integrity register
ret = str2num(query(interface, 'STAT:QUES:INT?'));</MCode>
               </Code>
               <Description>Sets up the status registers to report both an over-drive condition or an alignment request. No other conditions are monitored. use GetOvrDrvand AlignRqst to query registers.</Description>
            </Method>
            <Method>
               <Name>iGenSetTraceDet</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSetTraceDet(obj, TraceOrd, DetMode, RaiseError, ChkResult)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Create RaiseError and/or ChkREsult variables if they are not input.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

if ChkResult
  set(obj, 'iGenDetectorChkResult', DetMode);
else
  set(obj, 'iGenDetector', DetMode);
end</MCode>
               </Code>
               <Description>The E4440 does not support different detectors on traces so this is the same as iGenDetector or iGenDetectorChkResult depending on ChkResult input.
Allowed inputs for Detmode are the same as those set in the properties of iGenDetector. </Description>
            </Method>
            <Method>
               <Name>iGenSpanToMarkerDelta</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenSpanToMarkerDelta(obj, MkrOrd, RaiseError)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

interface = get(obj, 'interface');

if MkrOrd &gt;= 1 &amp;&amp; MkrOrd &lt;= 4
  [ModeNum, ~] = invoke(obj, 'iGenQMarkerMode', MkrOrd, RaiseError);
  if ModeNum == 2 % Delta
    fprintf(interface, ['CALC:MARK',num2str(MkrOrd),':SPAN']);
  else
    if RaiseError
      error('SA:Function:SpanToMarkerDelta:MkrWrongMode','The marker must be in Delta mode')
    end
  end
else
  if RaiseError
    error('SA:Function:SpanToMarkerDelta:InvalidInput','The marker number input is invalid. Must be 1-4.')
  end
end
</MCode>
               </Code>
               <Description>sets the span based on the separation of the delta markers.

If RaiseError = true then an error will be raised should one occur.</Description>
            </Method>
            <Method>
               <Name>iGenSweepTimeRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Range = iGenSweepTimeRange(obj, qInst, Span)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
if qInst || ~exist('Span', 'var')
  Span = str2double(query(interface, ':FREQ:SPAN?'));
end
if Span == 0
  Range = [.000001 6000];
else
  Range = [.001 2000];
end</MCode>
               </Code>
               <Description>Provides the available range of sweep times for the 4440.
If qInst = true or Span is not input then the E4440 is queried for the current Span.
This is then used to determine the sweep time range.

If span is entered then the entered value is used to deteremine the sweep time range.</Description>
            </Method>
            <Method>
               <Name>iGenSwpPntRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function Range = iGenSwpPntRange(obj, qInst, Span)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
if qInst || ~exist('Span', 'var')
  Span = str2double(query(interface, ':FREQ:SPAN?'));
end
if Span == 0
  Range = [2 8192];
else
  Range = [101 8192];
end</MCode>
               </Code>
               <Description>query the available sweep point range for the e4440

If qInst = true or Span is not input then the E4440 is queried for the current Span.
This is then used to determine the sweep point range.

If span is entered then the entered value is used to deteremine the sweep point range.</Description>
            </Method>
            <Method>
               <Name>iGenTakeSweep</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenTakeSweep(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface=get(obj,'interface');
% get sweep time for use later
ST = str2double(query(interface, 'SWE:TIME?'));

% set Time out to 1 minute to account for sweep start delay
set(interface, 'TimeOut', 60);

% Set the analyzer into single sweep mode
fprintf(interface,':INIT:CONT OFF');

% Trigger the sweep and wait for it to complete.
fprintf(interface,':INIT:IMM');
if ST &gt; 12
  pause(ST - 2);
end
query(interface, '*OPC?');</MCode>
               </Code>
               <Description>Tells analyzer to begin a sweep holds actions until sweep is complete.</Description>
            </Method>
            <Method>
               <Name>iGenTraceData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function data=iGenTraceData(obj, TraceOrd, NewTrace, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

if ~exist('RaiseError', 'var')
  RaiseError = false;
end

% Get the interface object
interface=get(obj,'interface');

if TraceOrd &gt; 0 &amp;&amp; TraceOrd &lt;= 3
  % get sweep time for use later
  ST = str2double(query(interface, 'SWE:TIME?'));
  
  % set Time out to 1 minute to account for sweep start delay
  set(interface, 'TimeOut', 60);
  
  % Tell it the precision
  fprintf(interface,':FORM:DATA REAL,32');
  
  % Set the analyzer into single sweep mode
  fprintf(interface,':INIT:CONT OFF');
  
  % Trigger the sweep and wait for it to complete if a new sweep is requested
  if NewTrace
    fprintf(interface,':INIT:IMM');
    if ST &gt; 12
      pause(ST - 2);
    end
    query(interface, '*OPC?');
  end
  
  % Get the data back
  fprintf(interface,[':TRACE:DATA? TRACE', num2str(TraceOrd)]);
  data=binblockread(interface,'float');
  
  % Reset the time out to 10 seconds
  set(interface, 'TimeOut', 10);
else
  % warning the SA only has three traces. Invalid trace number requested
  if RaiseError
    error('SA:Function:TraceData:InvalidInput',...
      'The E4440 only has three traces. The input trace order is invalid')
  else
    data = [];
  end
end


</MCode>
               </Code>
               <Description>This function reads the trace data from the E4440 and returns it as a row vector.

TraceOrd indicates which trace 1, 2, or 3
NewTrace is a boolean that indicates whether a new sweep should be performed before recording data
If RaiseError = true errors will be raised if a Matlab error is raised or an invalid input is entered.</Description>
            </Method>
            <Method>
               <Name>iGenTraceMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenTraceMode(obj, TraceOrd, TraceMode, RaiseError, ChkResult)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end
if ~exist('ChkResult', 'var')
  ChkResult = false;
end

[NumTraces, ~] = invoke(obj, 'iGenNumTraces');
interface = get(obj, 'interface');

if TraceOrd &gt;= 1 &amp;&amp; TraceOrd &lt;= NumTraces
  ValidInput = true;
  switch TraceMode
    case 0 % clear write
      sCmd = 'WRIT';
    case 1 % Max Hold
      sCmd = 'MAXH';
    case 2 % Min Hold
      sCmd = 'MINH';
    case 3 % View
      sCmd = 'VIEW';
    case 4
      sCmd = 'BLAN';
    otherwise
      % warning invalid input
      ValidInput = false;
  end
  if ValidInput
    fprintf(interface, [':TRAC',num2str(TraceOrd),':MODE ',sCmd]);
  else
    if RaiseError
      error('SA:Function:TraceMode:InvalidInput',...
        'The input trace mode is invalid');
    end
  end
else
  if RaiseError
    error('SA:Function:TraceMode:InvalidInput',...
      ['The input trace number is out of range. Must be 1-',num2str(NumTraces),'.']);
  end
end

% If ChkResult = RaiseError = true then check the setting and raise an
% error if it is not correct.
if RaiseError &amp;&amp; ChkResult
  [SetMode, ~] = invoke(obj, 'iGenQTraceMode', TraceOrd, RaiseError);
  if SetMode ~= TraceMode
    error('SA:Function:TraceMode:SettingIncorrect', 'The trace mode has not been set as requested');
  end
end</MCode>
               </Code>
               <Description>sets the trace mode of the specified trace (TraceOrd)
TraceModes:
0 = Clear Write
1 = Max Hold
2 = Min Hold
3 = View
4 = Blank

If RaiseError = true then errors will be raised for invlaid inputs.
If ChkREsult = RaiseError = true then an error will be raised if the setting is not set as requested.</Description>
            </Method>
            <Method>
               <Name>iGenTrigTraceData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [Success, data] = iGenTrigTraceData(obj, TraceOrd, WaitTime, RaiseError)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
if ~exist('RaiseError', 'var')
  RaiseError = false;
end

% Get the interface object
interface=get(obj,'interface');
Fail = false;

if TraceOrd &gt; 0 &amp;&amp; TraceOrd &lt;= 3
  % get sweep time for use later
  ST = str2double(query(interface, 'SWE:TIME?'));
  PauseTime = .001;
  % set Time out to 1 minute to account for sweep start delay
  tTO = ST + WaitTime + 1;
  
  % Tell it the precision
  fprintf(interface,':FORM:DATA REAL,32');
  Count = 1;
  
  % Set the analyzer into single sweep mode
  fprintf(interface,':INIT:CONT OFF');
  clearESR = str2double(query(interface, '*ESR?'));
  Finished = false;
  
  try
    tStart = tic;
    TotTime = toc(tStart);
    fprintf(interface,':INIT:IMM');
    % tell SA to set Operation complete status register.
    fprintf(interface, '*OPC');
    % poll the status register to determine is sweep has completed. If it
    % does not complete in the alotted time then break out of loop and
    % return that the sweep failed.
    while ~Finished &amp;&amp; TotTime &lt;= tTO;
      out = str2double(query(interface, '*ESR?'));
      OpCom = bitand(out, 1);
      if OpCom == 1
        Finished = true;
      end
      TotTime = toc(tStart);
      pause(.01)
    end
    if TotTime &gt; tTO
      Fail = true;
    end
  catch oops
    Fail = true;
  end
  
  % Get the data back
  if Fail
    data = [];
    Success = false;
  else
    fprintf(interface,[':TRACE:DATA? TRACE', num2str(TraceOrd)]);
    data=binblockread(interface,'float');
    Success = true;
  end
else
  % warning the SA only has three traces. Invalid trace number requested
  if RaiseError
    error('SA:Function:TrigTraceData:InvalidInput',...
      'The E4440 only has three traces. The input trace order is invalid')
  else
    data = [];
    Success = false;
  end
end

</MCode>
               </Code>
               <Description>This function commands the analyzer to take a sweep with the assumption that a trigger is in place. If the analyzer does not respond in time the empty set [], is returned and a boolean indicating that the trace timed out is also returned. input arguments are trace number, trace wait time, and RaiseError.</Description>
            </Method>
            <Method>
               <Name>iGenWriteSCPI</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iGenWriteSCPI(obj,cmd)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

interface=get(obj,'interface');

fprintf(interface,cmd);</MCode>
               </Code>
               <Description>Write_SCPI sends an SCPI string to the instrument

Input parameters: SCPI string
Output parameters: none

</Description>
            </Method>
            <Method>
               <Name>InitCaptureData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function InitCaptureData(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

% Set 
fprintf(interface,':INIT:TCAP');</MCode>
               </Code>
               <Description>Capture Time Data

Initiates the recording of data while in the Spectrum or Waveform
measurements. You must have PSA Option 122 or 140 installed and
have the wideband path selected SENSe:SPECtrum:IFPath WIDE or
SENSe:WAVeform:IFPath WIDE.
Example: INIT:TCAP
Remarks: You must be in the Basic mode to use this command.
Use INSTrument:SELect to set the mode.
History: Added with PSA revision A.06.00
Front Panel
Access: Meas Control, Capture Setup, Capture</Description>
            </Method>
            <Method>
               <Name>INITSA</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function INITSA(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');

ST = str2double(query(interface, 'SWE:TIME?'));
set(interface,'Timeout',ST + 2);  
fprintf(interface, 'STAT:OPER:ENAB 8'); %Enable sweeping status flag
fprintf(interface, 'INIT; *WAI'); % initiate sweep and wait for it to complete
dummyCmd = query(interface, 'SYST:ERR?');
set(interface,'Timeout', 10);  </MCode>
               </Code>
               <Description>Start a Sweep/Measurement
Causes instrument to exit the 'idle' state and go to the initiated state.
Once trigger conditions are met the sweep measurement will start.
This only works with SA in Spectrum Analyzer mode.

This may not work when waiting for a trigger due to timeout not being long enough</Description>
            </Method>
            <Method>
               <Name>NumMeasWindows</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseADCRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseAVG</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseAvgMode</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseAvgNum</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseAvgType</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseIQStats</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseMeas</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBasePRBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBasePreFFTfilt</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qBaseRBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qDone</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qERR</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qRANGES</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinVal, MaxVal, IncVal] = qRANGES(obj, WhichParm)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
switch WhichParm
  case 0 % Ref Level
    MinVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:RLEV? MIN'));
    MaxVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:RLEV? MAX'));
    IncVal = 1;
  case 1 % Attenuation
    MinVal = 0;
    MaxVal = 70;
    IncVal = 2;
  case 2 % Y Scale Per Div
    MinVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:PDIV? MIN'));
    MaxVal = str2double(query(interface, ':DISP:WIND:TRAC:Y:PDIV? MAX'));
    IncVal = .1;
  otherwise 
    %invalid input
    MinVal = [];
    MaxVal = [];
    IncVal = [];
end


</MCode>
               </Code>
               <Description>Given the current analyzer settings this function queries for the min, max and increment for each of the following parameters (WhichParm)
WhichParm = 0 --&gt; Reference Level
WhichParm = 1 --&gt; Attenuation
WhichParm = 2 --&gt; Y-Axis Scale per division</Description>
            </Method>
            <Method>
               <Name>qRLRANGE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function out = qRLRANGE(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
interface = get(obj, 'interface');
MinRL = str2double(query(interface,':DISP:WIND:TRAC:Y:RLEV? MIN'));
MaxRL = str2double(query(interface,':DISP:WIND:TRAC:Y:RLEV? MAX'));
out = [MinRL : MaxRL];</MCode>
               </Code>
               <Description>query available reference level values</Description>
            </Method>
            <Method>
               <Name>qTRIGDELAY</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>qTRIGLEVEL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>RCLS</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>RCLT</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>RL2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SAInitiate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SAInitiate(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
% Get the interface object
interface=get(obj,'interface');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

% Set 
fprintf(interface,':INIT:WAV');</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SAMeasCHP</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SAMeasCHP(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
</MCode>
               </Code>
               <Description>TO BE USED IN SA MODE</Description>
            </Method>
            <Method>
               <Name>SAMeasOBW</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SAMeasOBW(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
</MCode>
               </Code>
               <Description>Sets the Occupied bandwidth in SA mode (only used in SA mode).</Description>
            </Method>
            <Method>
               <Name>SAPeakAcq</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [freq,amp] = SAPeakAcq(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Set the analyzer into single sweep mode
fprintf(interface,':INIT:CONT OFF');

% Trigger the sweep and wait for it to complete
fprintf(interface,':INIT:IMM;*WAI');

% Get the data back
peaks = str2num(query(interface,':TRAC:MATH:PEAK?'));

freq = peaks(1:2:end-1)';
amp = peaks(2:2:end)';

fprintf(interface,':INIT:CONT ON');
</MCode>
               </Code>
               <Description>getPeaks queries the peak list the meets the peak threshold and peak excursion criteria.

Iutput parameters: none
Output parameters: two column vectors, the first is the frequency points an the second is the amplitude peak values.

 example: [freq amp] = invoke(mxa_handle, 'SAPeakAcq'')

FOR USE WITH MXA</Description>
            </Method>
            <Method>
               <Name>SAVES</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SAVET</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SCALEPERDIV2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>SPVAL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [MinSpan, MaxSpan] = SPVAL(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
MinSpan = str2double(query(interface, ':FREQ:SPAN? MIN'));
MaxSpan = str2double(query(interface, ':FREQ:SPAN? MAX'));</MCode>
               </Code>
               <Description>queries for the min and max allowable spans</Description>
            </Method>
            <Method>
               <Name>SYSMESSAGE</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function SYSMESSAGE(obj, Msg)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
interface = get(obj, 'interface');
if strcmpi(Msg, '')
  cmdStr = 'SYST:MESS:OFF';
else
  cmdStr = ['SYST:MESS "',Msg,'"'];
end
fprintf(interface, cmdStr);</MCode>
               </Code>
               <Description>display message on instrument screen</Description>
            </Method>
            <Method>
               <Name>TRIGDELAY</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>TRIGLEVEL</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>WavDeepCapture</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iq=WavDeepCapture(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

interface=get(obj,'interface');
N=query(interface,'TCAP:LREC?');
N=str2num(N);


fprintf(interface,':FORM:DATA REAL,32');

IQData=[];
tic
for x = 1:N;
    x;
    fprintf(interface,':READ:WAV0?');
    Record=binblockread(interface,'float');
    fread(interface,1);Ag
    IQData=[IQData;Record];
end
toc
% data is interleaved inphase, quad

inphase=IQData(1:2:end);
quad=IQData(2:2:end);
 
% final complex vector
iq=inphase+j*quad;

</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>WavFetchIQData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iq=WavFetchIQData(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

fprintf(interface,':FETCH:WAV0?');

% Get the data back
data=binblockread(interface,'float');
fread(interface,1);

% data is interleaved inphase, quad
inphase=data(1:2:end);
quad=data(2:2:end);

% final complex vector
iq=inphase+j*quad;</MCode>
               </Code>
               <Description>This command puts selected data from the most recent measurement into the output buffer. Use
FETCh if you have already made a good measurement and you want to return several types of
data (different [n] values, e.g. both scalars and trace data) from a single measurement. FETCh
saves you the time of re-making the measurement. You can only FETCh results from the
measurement that is currently active, it will not change to a different measurement.
If you need to get new measurement data, use the READ command, which is equivalent to an
INITiate followed by a FETCh.
The scalar measurement results will be returned if the optional [n] value is not included, or is set
to 1. If the [n] value is set to a value other than 1, the selected trace data results will be returned.
See each command for details of what types of scalar results or trace data results are available.
The binary data formats should be used for handling large blocks of data since they are smaller
and transfer faster then the ASCII format. (FORMat:DATA)
FETCh may be used to return results other than those specified with the original READ
or MEASure command that you sent.</Description>
            </Method>
            <Method>
               <Name>WavInitIQData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function WavInitIQData(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

% Set 
fprintf(interface,':INIT:WAV');</MCode>
               </Code>
               <Description>This command is not available for measurements in all the instrument modes:

 Initiates a trigger cycle for the specified measurement, but does not output any data. You
must then use the FETCh&lt;meas&gt; command to return data. If a measurement other than the
current one is specified, the instrument will switch to that measurement and then initiate it.
For example, suppose you have previously initiated the ACP measurement, but now you are
running the channel power measurement. If you send INIT:ACP? it will change from channel
power to ACP and will initiate an ACP measurement.
 Does not change any of the measurement settings. For example, if you have previously
started the ACP measurement and you send INIT:ACP? it will initiate a new ACP
measurement using the same instrument settings as the last time ACP was run.
 If your selected measurement is currently active (in the idle state) it triggers the
measurement, assuming the trigger conditions are met. Then it completes one trigger
cycle. Depending upon the measurement and the number of averages, there may be
multiple data acquisitions, with multiple trigger events, for one full trigger cycle. It
also holds off additional commands on GPIB until the acquisition is complete.</Description>
            </Method>
            <Method>
               <Name>WavMeasIQData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iq=WavMeasIQData(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Change instrument mode to spectrum analyzer
fprintf(interface,':INST:NSEL 8');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

% Set the Occupied Bandwidth Meas Mode
fprintf(interface,':MEAS:WAV?');

% Get the data back
data=binblockread(interface,'float');
fread(interface,1);

% data is interleaved inphase, quad
inphase=data(1:2:end);
quad=data(2:2:end);

% final complex vector
iq=inphase+j*quad;</MCode>
               </Code>
               <Description>:MEASure:&lt;measurement&gt;[n]?
This is a fast single-command way to make a measurement using the factory default
instrument settings. These are the settings and units that conform to the Mode Setup
settings (e.g. radio standard) that you have currently selected.

 Stops the current measurement (if any) and sets up the instrument for the specified
measurement using the factory defaults
 Initiates the data acquisition for the measurement
 Blocks other SCPI communication, waiting until the measurement is complete before
returning results.
 If the function does averaging, it is turned on and the number of averages is set to 10.
 After the data is valid it returns the scalar results, or the trace data, for the specified
measurement. The type of data returned may be defined by an [n] value that is sent with the
command.
The scalar measurement results will be returned if the optional [n] value is not included, or is
set to 1. If the [n] value is set to a value other than 1, the selected trace data results will be
returned. See each command for details of what types of scalar results or trace data results
are available.
ASCII is the default format for the data output. Older versions of Spectrum Analysis and
Phase Noise mode measurements only use ASCII.) The binary data formats should be used
for handling large blocks of data since they are smaller and faster than the ASCII format.
Refer to the FORMat:DATA command for more information.
If you need to change some of the measurement parameters from the factory default
settings you can set up the measurement with the CONFigure command. Use the
commands in the SENSe:&lt;measurement&gt; and CALCulate:&lt;measurement&gt; subsystems
to change the settings. Then you can use the READ? command to initiate the
measurement and query the results. See Figure 1.
If you need to repeatedly make a given measurement with settings other than the
factory defaults, you can use the commands in the SENSe:&lt;measurement&gt; and
CALCulate:&lt;measurement&gt; subsystems to set up the measurement. Then use the
READ? command to initiate the measurement and query results.
Measurement settings persist if you initiate a different measurement and then return to
a previous one. Use READ:&lt;measurement&gt;? if you want to use those persistent settings.
If you want to go back to the default settings, use MEASure:&lt;measurement&gt;?.</Description>
            </Method>
            <Method>
               <Name>WavReadIQData</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function iq=WavReadIQData(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

% Get the interface object
interface=get(obj,'interface');

% Tell it the precision
fprintf(interface,':FORM:DATA REAL,32');

fprintf(interface,':READ:WAV0?');

% Get the data back
data=binblockread(interface,'float');
fread(interface,1);

% data is interleaved inphase, quad
inphase=data(1:2:end);
quad=data(2:2:end);

% final complex vector
iq=inphase+j*quad;
</MCode>
               </Code>
               <Description>For PSA this measures the amplitude of your input signal with respect to the frequency. It provides spectrum analysis capability using FFT(fast Fourier transform) measurement techniques. You must be in the Basic, cdmaOne, cdma2000, 1xEV-DO, W-CDMA, GSM (w/EDGE),
NADC, or PDC mode to use these commands. Use INSTrument:SELect,
to select the mode.

The general functionality of READ are described below. See the SENSe:WAVeform
commands for more measurement related commands.

:READ:&lt;measurement&gt;[n]?
 Does not preset the measurement to the factory default settings. For example, if you have
previously initiated the ACP measurement and you send READ:ACP? it will initiate a new
measurement using the same instrument settings.
 Initiates the measurement and puts valid data into the output buffer. If a measurement other
than the current one is specified, the instrument will switch to that measurement before it
initiates the measurement and returns results.
For example, suppose you have previously initiated the ACP measurement, but now you are
running the channel power measurement. Then you send READ:ACP? It will change from
channel power back to ACP and, using the previous ACP settings, will initiate the
measurement and return results.
 Blocks other SCPI communication, waiting until the measurement is complete before
returning the results
If the optional [n] value is not included, or is set to 1, the scalar measurement results
will be returned. If the [n] value is set to a value other than 1, the selected trace data
results will be returned. See each command for details of what types of scalar results
or trace data results are available. The binary data formats should be used when
handling large blocks of data since they are smaller and faster then the ASCII
format. (FORMat:DATA)</Description>
            </Method>
            <Method>
               <Name>XAxisUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>YAxisUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands/>
               </Code>
               <Description/>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>